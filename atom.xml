<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>酒酒</title>
  
  <subtitle>“生活明朗，万物可爱”</subtitle>
  <link href="https://jiujiu.tj.cn/atom.xml" rel="self"/>
  
  <link href="https://jiujiu.tj.cn/"/>
  <updated>2023-07-22T03:57:15.506Z</updated>
  <id>https://jiujiu.tj.cn/</id>
  
  <author>
    <name>酒酒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git关联Github</title>
    <link href="https://jiujiu.tj.cn/[object%20Object]/Git%E5%85%B3%E8%81%94Github/"/>
    <id>https://jiujiu.tj.cn/[object%20Object]/Git%E5%85%B3%E8%81%94Github/</id>
    <published>2023-07-08T07:46:27.000Z</published>
    <updated>2023-07-22T03:57:15.506Z</updated>
    
    <content type="html"><![CDATA[<p>Git 安装</p><p>一、下载安装</p><p><a href="https://git-scm.com/download">安装包</a></p><p><img src="https://s2.loli.net/2023/07/08/ps1Fkt2YeBwRJIc.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/TnpKhDHLouiMsBt.png" alt=""></p><p>下载完成后，直接点击安装包安装，</p><p>开始安装，然后下一步</p><p><img src="https://s2.loli.net/2023/07/08/TBl7IcuiL6e5xAD.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/PFXiubpscw6vVky.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/yCARWlESxrohIz1.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/8T3h72sSmwg4KxX.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/iAaw7byrJO9jTDF.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/UtFhLa8sCdiD5eY.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/M5N4QghtbalBZiE.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/JKyQXO8BavTEuRH.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/lMv4rIk6hBNtjfm.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/bRhy83EmjQYe1uN.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/bSkyg28RKn43tvs.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/Q1b3Pwr7X2gOzhR.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/b9UWqlNsQtP48Zd.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/87dDfoczFCi9uQ1.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/LRh1ZyzfHirsklx.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/08/hV1GYMP4JRqaNt7.png" alt=""></p><p>二、配置</p><p>桌面右键 ——&gt;git bash here</p><p><img src="https://s2.loli.net/2023/07/08/iBbx8TunEjIQX2e.png" alt=""></p><p>配置邮箱和用户名 (–global 表示全局配置)</p><pre class=" language-language-bash"><code class="language-language-bash">#配置用户名   //填写需要连接的git仓库个人用户名，这里使用的是githubgit config --global user.name "用户名"#配置邮箱   //填写需要连接的git仓库个人邮箱git config --global user.email  "邮箱"</code></pre><p><img src="https://s2.loli.net/2023/07/08/Wvyru5IT19VUMpj.png" alt=""></p><p>查询配置：git config --global --list</p><p>生成 ssh 文件夹（生成 ssh 秘钥）（输入 $ ssh-keygen -t rsa，敲击三次回车键），文件目录 - C:\Users\ 用户名.ssh；</p><p><img src="https://s2.loli.net/2023/07/08/LApiTFwXa3BZ9C5.png" alt=""></p><p>如果看不到.ssh 文件夹，查看文件夹属性，勾选显示隐藏文件夹</p><p>将 ssh 文件夹中的公钥（ id_rsa.pub）添加到 GitHub 管理平台中（添加后会收到邮件提示）</p><p><img src="https://s2.loli.net/2023/07/08/HNKiwoOQuvphetm.png" alt=""></p><p>git 如何创建本地版本库</p><p>测试秘钥配置</p><pre class=" language-language-bash"><code class="language-language-bash">ssh -T git@github.com#按照提示输入yes,看到successfully我们就知道配置成功了</code></pre><p><img src="https://s2.loli.net/2023/07/08/pi7ebF9zPhS6W4L.png" alt=""></p><p>托管到 GitHub</p><pre class=" language-language-bash"><code class="language-language-bash">#进入到博客同级目录下</code></pre><p><img src="https://s2.loli.net/2023/07/08/rk8ECLKnFZtPTmS.png" alt=""></p><pre class=" language-language-bash"><code class="language-language-bash">#克隆远端的github仓库，使之生成同名仓库目录git clone git@github.com:jiujiu-del/like-jiujiu.del.git#在到博客根目录下打开cmdhexo cleanhexo g#把生成的public里面文件全部复制到本地仓库目录下#复制完后同样打开cmdgit add --allgit commit -m '标签'git push --all</code></pre><p><img src="https://s2.loli.net/2023/07/08/HcMKhCNsSFE2lpe.png" alt=""></p><p>验证</p><pre class=" language-language-bash"><code class="language-language-bash">#仓库名.github.io</code></pre><p>部署到自己的域名</p><p>购买域名…（就不介绍了）</p><p>Github 绑定域名：</p><p>进入控制台找到域名管理，解析域名</p><p><img src="https://s2.loli.net/2023/07/08/XVx4iOWQaKYDJq8.png" alt=""></p><p>进入页面点击添加记录即可；要添加两个记录值，记录类型分别为 A 和 CNAME，填写如下。</p><pre class=" language-language-bash"><code class="language-language-bash">#记录类型为A主机记录为：@记录值为自己git.io那个ip地址。IP地址在cmd中ping一下即可; 一般都是这个:185.199.110.153#记录类型为CNAME主机记录为www记录值为自己的github访问地址。我这里填写 zsc-cloud.github.io</code></pre><p>Hexo 配置域名</p><pre class=" language-language-bash"><code class="language-language-bash">在自己博客的跟目录source文件夹下创建一个名字CNAME记事本内容输入自己的个人域名，保存关闭。删除后缀.tx</code></pre><p>仓库绑定域名</p><pre class=" language-language-bash"><code class="language-language-bash">在GitHub中找到自己的博客仓库，点击setting，拉到最下面找到GitHub Pages点进去在Custom domain输入自己的域名save一下即可，效果如下就说明配置成功了</code></pre><p><img src="https://s2.loli.net/2023/07/08/iYnyPAoG2astDCT.png" alt=""></p><p>Https</p><pre class=" language-language-bash"><code class="language-language-bash">如果GitHub上可以开启Https直接开启即可，如果不能的话可以在阿里云申请一个免费的SSL证书在这里就不展开说明了，按照提示操作即可</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Git 安装&lt;/p&gt;
&lt;p&gt;一、下载安装&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/download&quot;&gt;安装包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/07/08/ps1Fkt2YeBwRJI</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Centos_Nginx-源码安装</title>
    <link href="https://jiujiu.tj.cn/[object%20Object]/Centos-Nginx-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
    <id>https://jiujiu.tj.cn/[object%20Object]/Centos-Nginx-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</id>
    <published>2023-07-07T12:49:04.000Z</published>
    <updated>2023-07-22T03:57:15.768Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx - 源码安装</p><p>源码包获取方式：<br>软件官网获取下载： <a href="https://nginx.org/en/">https://nginx.org/en/</a></p><p><img src="https://s2.loli.net/2023/07/07/EkRQTiOxJ6HlvWq.png" alt=""></p><p>选择版本，这里选择旧版 1.22.1；右键选择复制链接地址</p><p><img src="https://s2.loli.net/2023/07/07/JBl5ZzhEWiItYjc.png" alt=""></p><pre class=" language-language-bash"><code class="language-language-bash">wget https://nginx.org/download/nginx-1.22.1.tar.gz</code></pre><p>虚拟机终端使用 wget 下载源码包</p><p><img src="https://s2.loli.net/2023/07/07/qNpyl95If3vh7XU.png" alt=""></p><pre class=" language-language-bash"><code class="language-language-bash">#解压tar xf nginx-1.22.1.tar.gz#创建生成目录mkdir /opt/app#移动到解压后的Nginx源码包cd /root/nginx-1.22.1</code></pre><p><img src="https://s2.loli.net/2023/07/07/Dx5nNOa61sPEmt7.png" alt=""></p><pre class=" language-language-bash"><code class="language-language-bash">#安装依赖yum install -y openssl-devel pcre-devel gcc gcc-c++ glibc -y#生成./configure --prefix=/opt/app/nginx-1.22.1 --with-http_ssl_module --with-http_stub_status_module</code></pre><p>生成完成如下</p><p><img src="https://s2.loli.net/2023/07/07/C7HKhOwXScIDmf8.png" alt=""></p><pre class=" language-language-bash"><code class="language-language-bash"># 编译安装（为了让系统能识别你的代码，并且吧刚才指定的功能和路径编辑到源码中）make  && make install</code></pre><p>安装完成如图下：</p><p><img src="https://s2.loli.net/2023/07/07/zY9qfl4ai5teDPn.png" alt=""></p><pre class=" language-language-bash"><code class="language-language-bash">#做软链接ln -s /opt/app/nginx-1.22.1 /opt/app/nginx#添加环境变量echo 'export PATH="$PATH:/opt/app/nginx/sbin"' >> /etc/profile.d/nginx.sh# 生效环境变量source /etc/profile</code></pre><p>添加系统启动脚本</p><p>vim /usr/lib/systemd/system/nginx.service</p><pre class=" language-language-bash"><code class="language-language-bash">[Unit]Description=nginx - high performance web serverAfter=network.target[Service]Type=forkingExecStartPre=/opt/app/nginx/sbin/nginx -t -c /opt/app/nginx/conf/nginx.confExecStart=/opt/app/nginx/sbin/nginx -c /opt/app/nginx/conf/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre><pre class=" language-language-bash"><code class="language-language-bash">#重新加载文件systemctl daemon-reload#授权脚本chmod +x /usr/lib/systemd/system/nginx.service#启动服务</code></pre><p><img src="https://s2.loli.net/2023/07/07/QKeuEOsJoXpPRBG.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Nginx - 源码安装&lt;/p&gt;
&lt;p&gt;源码包获取方式：&lt;br&gt;
软件官网获取下载： &lt;a href=&quot;https://nginx.org/en/&quot;&gt;https://nginx.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NodeJs的安装及配置环境变量</title>
    <link href="https://jiujiu.tj.cn/[object%20Object]/NodeJs%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://jiujiu.tj.cn/[object%20Object]/NodeJs%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2023-07-07T08:40:16.000Z</published>
    <updated>2023-07-22T03:57:15.519Z</updated>
    
    <content type="html"><![CDATA[<p>NodeJs 的安装及配置环境变量一、Node.js 下载与安装二、Node.js 环境变量配置三、国内镜像网站配置</p><p>NodeJs 的安装及配置环境变量</p><p>一、Node.js 下载与安装</p><p>进入官网地址下载安装包</p><p><a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></p><p><img src="https://s2.loli.net/2023/07/07/G4fUNm5Y7E2wedO.png" alt=""></p><p>下载完成后，双击安装包，开始安装，使用默认配置安装一直点 <code>next</code>  即可，安装路径默认在 <code>C:\Program Files</code>  下，也可以自定义修改</p><p><img src="https://s2.loli.net/2023/07/07/5Q1zPWrGMwqFJ2b.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/07/tupxgUyVob24YAd.png" alt=""></p><p>安装路径默认在 C:\Program Files 下面，也能够自定义修改，而后点击 next</p><p><img src="https://s2.loli.net/2023/07/07/3qlmpZxeGjMyvPd.png" alt=""></p><pre><code> Node.js runtime ：表示运行环境 npm package manager：表示npm包管理器 online documentation shortcuts ：在线文档快捷方式 Add to PATH：添加到环境变量</code></pre><p><img src="https://s2.loli.net/2023/07/07/HgwljYDMx6eKfAv.png" alt=""></p><p>以下图框中所示，我没有选中，而是直接 next</p><p><img src="https://s2.loli.net/2023/07/07/kUrOGNeQSTHVXlD.png" alt=""></p><p>点击 Install，进行安装</p><p><img src="https://s2.loli.net/2023/07/07/C7z6I2FesuX8B41.png" alt=""></p><p>点击 finish，完成安装</p><p><img src="https://s2.loli.net/2023/07/07/rfeTRjlPu7tKZ5Y.png" alt=""></p><p>二、Node.js 环境变量配置</p><p>安装完成后，.msi 格式的安装包已经将 node 启动程序添加到系统环境变量 path 中，咱们能够查看系统变量进行验证：在【设置】→【高级系统设置】</p><p><img src="https://s2.loli.net/2023/07/07/hZkyBY7NfxvgV2O.png" alt=""></p><p>选择环境变量：修改 Path 变量</p><p><img src="https://s2.loli.net/2023/07/07/UIO2jVYy3MorWpG.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/07/q2iDT5uzG9g6bPp.png" alt=""></p><p>选择系统变量，修改 Path</p><p><img src="https://s2.loli.net/2023/07/07/tqIy6naYuxodFLz.png" alt=""></p><p><img src="https://s2.loli.net/2023/07/07/24ly9qU1HJtLTQG.png" alt=""></p><p>查看： 既然已经将 node 程序添加到全局系统变量中，打开 CMD 窗口，执行命令 <code>node -v</code>  查看 node 版本，最新版的 node 在安装时同时也安装了 npm, 执行 <code>npm -v</code>  查看 npm 版本</p><p><img src="https://s2.loli.net/2023/07/07/CByTXrl2Hain5Gu.png" alt=""></p><p>一部分经常使用的命令，以下：</p><ul><li>npm -v：查看 npm 安装的版本。</li><li>npm init：会引导你建立一个 package.json 文件，包括名称、版本、作者等信息。</li><li>npm list：查看当前目录下已安装的 node 包。</li><li>npm ls：查看当前目录下已安装的 node 包。</li><li>npm install moduleNames：安装 Node 模块到本地目录 node_modules 下。</li><li>npm install &lt;name&gt; -g：将包安装到全局环境中。</li><li>npm install &lt;name&gt; --save：安装的同时，将信息写入 package.json 中，项目路径中若是有 package.json 文件时，直接使用 npm install 方法就能够根据 dependencies 配置安装全部的依赖包，这样代码提交到 git 时，就不用提交 node_modules 这个文件夹了。</li><li>npm install &lt;name&gt; --save-dev：安装的同时，将信息写入 package.json 中项目路径中若是有 package.json 文件时，直接使用 npm install 方法就能够根据 devDependencies 配置安装全部的依赖包，这样代码提交到 git 时，就不用提交 node_modules 这个文件夹了。</li><li>npm uninstall moudleName：卸载 node 模块。</li><li>npm config get registry  查看镜像源</li></ul><p>三、国内镜像网站配置</p><p>npm 安装模块时都是去国外的镜像下载的，可是有的时候因为网络等缘由致使安装模块失败，好在阿里有团队维护国内镜像 <a href="https://link.zhihu.com/?target=https%3A//npmmirror.com/">淘宝 NPM 镜像</a></p><p>添加国内镜像源：如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre class=" language-language-bash"><code class="language-language-bash"> npm config set registry https://registry.npm.taobao.org</code></pre><p>查看是否更换成功</p><p><img src="https://s2.loli.net/2023/07/07/S146DyNlwLg5ZXa.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;NodeJs 的安装及配置环境变量一、Node.js 下载与安装二、Node.js 环境变量配置三、国内镜像网站配置&lt;/p&gt;
&lt;p&gt;NodeJs 的安装及配置环境变量&lt;/p&gt;
&lt;p&gt;一、Node.js 下载与安装&lt;/p&gt;
&lt;p&gt;进入官网地址下载安装包&lt;/p&gt;
&lt;p&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基础总结</title>
    <link href="https://jiujiu.tj.cn/[object%20Object]/%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>https://jiujiu.tj.cn/[object%20Object]/%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-07T07:39:03.000Z</published>
    <updated>2023-07-22T03:57:15.513Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><p>markdaown 语法</p><pre class=" language-language-bash"><code class="language-language-bash">基础语法标题：一级标题[# 正文]二级标题[## 正文]目录：[TOC]加粗字体：**正文**倾斜字体：*正文*超链接：[正文](网址)分割线：---空格语法框：```bash    #快捷： ctrl+shift+k穿插图片：![](图片位置路径)分类;[减号空格]二级分类：[删除减号空格]后此类推，回到一级分类：回车回车...高亮：``正文``插入表格：| | |  #快捷：ctrl+t勾选：【减号空格中括号x】 [- [x] ]颜色选项：例<font color = 'red'>苹果</font>  '可以写任何颜色'引用：>空格</code></pre><p>计算机的组成</p><pre class=" language-language-bash"><code class="language-language-bash">#计算机的组成：显示器##硬件 主板：搭载其他硬件 CPU：计算机的大脑 内存：临时储存空间 磁盘：永久储存空间 显卡：处理图片 电源：给计算机供电 风扇：给CPU散热 ##输出和输入设备 显示器 鼠标麦克风</code></pre><p>网络连接的三种定义</p><p>桥接模式</p><pre class=" language-language-bash"><code class="language-language-bash">桥接模式下虚拟机和主机同处于一个网段，物理机可以ping虚拟机，虚拟机也可以ping物理机但是，这种模式下虚拟机的安全性会受到很大威胁，因为只要知道物理机IP外部就可以谁都访问虚拟机</code></pre><p>NAT 模式</p><pre><code>虚拟机和主机构建一个专用网络，并通过虚拟机网络地址转换(nat)设备对物理机ip进行转换，虚拟机通过共享主机ip可以访问外部网络但是，其他物理机访问不了虚拟机，只局限于本台物理机访问</code></pre><p>仅主机模式</p><pre><code>物理机与主机共用一个网络，无法访问外部，</code></pre><p>IP 丶网关丶子网掩码丶 DNS</p><pre class=" language-language-bash"><code class="language-language-bash">IP:ipv4（Internet Protocol version 4）由4个8位二进制位表示，每8位有一个.隔开。8位二进制位的范围是0-255。根据IPv4地址的第一个字节（前8位），可对其分为A-E类，其中A类为0-126，B类为128-191，C类为192-223,127.0.0.1为回环地址子网掩码:子网掩码跟ip地址成对存在。如255.255.255.0就说明ip前24位为网段位，剩余8位为主机位。一段为8个位，在一个局域网里，同一网段的两ip能互相连接。网关：（Gateway）能实现不同网络之间的互相通信。网关是一个ip地址，一般为同一网段的第一个有效地址或最后一个。如网关192.168.154.2是该网段的第二个有效地址（192.168.154.0是网段，192.168.154.255是广播地址，192.168.154.1到192.168.154.254是该网段有效ip地址）DNS:域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。平时浏览网页明显是用一串字符访问的，但要与服务器通信当然要知道该服务器的ip地址，用ip地址访问。所以中间是先访问了DNS服务器，DNS给我们把字符串解析成ip了，然后再用ip访问所想的服务器。当然如果已经知道访问的字符串对应ip地址了，就不用请求DNS了，比如有缓存</code></pre><p>修改网卡</p><pre class=" language-language-bash"><code class="language-language-bash">#修改IP或者设置为静态， 网卡的配置文件编辑[root@hadoop102 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33TYPE="Ethernet"         #网卡类型：为以太网PROXY_METHOD="none"     #代理方式：关闭状态BROWSER_ONLY="no"BOOTPROTO="static"      #IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议动态获取ip）IPADDR=10.10.10.10     #本机地址（静态方式需要指定本地Ip,dhcp动态获取不需要这个字段）NETMASK=24              #子网掩码  或者255.255.255.0DEFROUTE="yes"IPV4_FAILURE_FATAL="no"  # 是否开启IPV4致命错误检测：否IPV6INIT="yes"          # IPV6是否自动初始化: 是  IPV6_AUTOCONF="yes"      #IPV6是否自动配置：是IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"     # IPV6地址生成模型NAME="ens33"        #网卡名字（与DEVICE一致）UUID="fcf797fd-b300-4106-9123-daec72ca6e92"DEVICE="ens33"         #接口名（设备,网卡)ONBOOT="yes"           #系统启动的时候网络接口是否有效（yes/no）                                                 </code></pre><p>虚拟机的克隆和快照</p><p>快照：</p><pre><code>快照相当于存档意思，可以在我们虚拟机出现文档损害情况下，使用快照回档恢复到文档损害之前</code></pre><p>克隆：</p><pre><code>克隆的前提条件;不能克隆处于开机状态下或者挂起的虚拟机，开机状态保存的快照也不能保存，只能克隆关机状态下的虚拟机类似于复制一份当前虚拟机状态</code></pre><p>shell 命令初始</p><pre class=" language-language-bash"><code class="language-language-bash">命令 [-options] [ ] command - 选项 参数  命令空格[选项]空格[参数] ls --> 目录 list #列表形式展开   -1   每列仅显示一个文件或目录名称。  -a或--all   列出目录下所有文件和目录，包括以 . 开头的隐含文件。  -A或--almost-all   显示所有文件和目录，但不显示现行目录（当前目录）和上层目录（当前目录的父目录）。  -b或--escape   显示脱离字符，即以八进制溢出序列表示不可打印的字符。  -B或--ignore-backups   忽略备份文件和目录，即不列出任何以"~"字符结束的项目。  -c   以更改时间排序，显示文件和目录。  -C   以又上至下，从左到右的直行方式显示文件和目录名称。  -d或--directory   显示目录名称而非其内容。  -D或--dired   用Emacs的模式产生文件和目录列表。  -f   对输出的文件不进行排序，-aU 选项生效，-lst 选项失效。  -F或--classify   在执行文件，目录，Socket，符号连接，管道名称后面，各自加上"*","/","=","@","|"号。  -g   次参数将忽略不予处理，即类似 -l,但不列出所有者。  -G或--no-group   不显示群组名称。  -h或--human-readable   用"K","M","G"来显示文件和目录的大小。  -H或--si   此参数的效果和指定"-h"参数类似，但计算单位是1000Bytes而非1024Bytes。  -i或--inode   显示文件和目录的inode编号。  -I<范本样式>或--ignore=<范本样式>   不显示符合范本样式的文件或目录名称。  -k或--kilobytes   此参数的效果和指定"block-size=1024"参数相同。  -l   使用详细格式列表，除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。ls -l 等于 ll  -L或--dereference   如遇到性质为符号连接的文件或目录，直接列出该连接所指向的原始文件或目录。  -m   用","号区隔每个文件和目录的名称。  -n或--numeric-uid-gid   以用户识别码和群组识别码替代其名称。  -N或--literal   直接列出文件和目录名称，包括控制字符。  -o   此参数的效果和指定"-l" 参数类似，但不列出群组名称或识别码。  -p或--file-type   此参数的效果和指定"-F"参数类似，但不会在执行文件名称后面加上"*"号。  -q或--hide-control-chars   用"?"号取代控制字符，列出文件和目录名称。  -Q或--quote-name   把文件和目录名称以""号标示起来。  -r或--reverse   反向排序。  -R或--recursive   递归处理，将指定目录下的所有文件及子目录一并处理。  -s或--size   显示文件和目录的大小，以区块为单位。  -S   用文件和目录的大小排序。  -t   用文件和目录的更改时间排序。  -T<跳格字符>或--tabsize=<跳格字数>   设置跳格字符所对应的空白字符数。  -u   以最后存取时间排序，显示文件和目录。       同-lt 一起使用：按照访问时间排序并显示。   同-l一起使用：显示访问时间并按文件名排序。   其他：按照访问时间排序。  -U   列出文件和目录名称时不予排序，以文件系统原有的次序列出项目。  -v   文件和目录的名称列表以版本进行排序。  -w<每列字符数>或--width=<每列字符数>   设置每列的最大字符数。  -x   以从左到右，由上至下的横列方式显示文件和目录名称。  -X   以文件和目录的最后一个扩展名排序。  --block-size=<区块大小>   指定存放文件的区块大小。  --color=<列表格式>   培植文件和目录的列表格式。  --full-time   列出完整的日期与时间。  --help   在线帮助。  --indicator-style=<标注样式>   在文件和目录等名称后面加上标注，易于辨识该名称所属的类型。  --quoting-syte=<引号样式>   把文件和目录名称以指定的引号样式标示起来。  --show-control-chars   在文件和目录列表时，使用控制字符。  --sort=<排序方式>   配置文件和目录列表的排序方式。  --time=<时间戳记>   用指定的时间戳记取代更改时间。  --version   显示版本信息。</code></pre><p>bashshell 的基本特性</p><pre class=" language-language-bash"><code class="language-language-bash">当使用windows查找一个目录层级特别多的文件时，打开的效率会非常的慢，但如果使用linux查找一个目录 层级特别多的文件时，可以通过tab键快速补全。# 命令补全 选项补全</code></pre><p>终端命令快捷键</p><pre class=" language-language-bash"><code class="language-language-bash">ctrl + l 清屏 ctrl + c 终止命令的执行 ctrl + a 让光标跳转至行首 ctrl + e 让光标跳转至行末 ctrl + w 以空格为分隔符，删除光标前到空格的距离 ctrl + d 退出登录 ctrl + z 将命令挂后台运行 ctrl + k 删除光标所在到行末的所有 ctrl + u 删除光标所在行至行首的所有 ctrl + r 搜索历史命令 关键字查找 ctrl + s 锁屏 ctrl + q 解锁 ctrl + ← 左移动 ctrl + → 右移动 ESC + . 获取上一条命令最后的参数</code></pre><p>历史命令 history</p><pre class=" language-language-bash"><code class="language-language-bash"># 查看历史命令 history # 清空历史命令 history -c # 删除指定的历史命令 history -d （编号） # 保存历史命令到文件 history -w # 保存的路径/root/.bash_history# 执行上一条命令 !!# 执行上一条相关命令 ！vi# 执行历史命令中的命令 ！（编号</code></pre><p>alias 别名</p><pre class=" language-language-bash"><code class="language-language-bash"># 临时设置别名，一旦重启就会失效 例：alias hi='history' alias wk='vi /etc/sysconfig/network-scripts/ifcfg-ens33' # 取消临时别名 unalias (别名名称)   如：unalias hi unalias wk # 永久设置别名，修改配置文件： vi /etc/bashrc 按G 跳转至文本最后一行 按o 在光标所在行下面进入编辑模式 输入你要设置的别名 alias tong='ping baidu.com' # 生效文件 source /etc/bashrc# 查看所有别名 alias</code></pre><p>命令帮助手册</p><pre class=" language-language-bash"><code class="language-language-bash">#获取ls命令的帮助[root@hadoop100 ~]#ls  --helpman [命令]</code></pre><p>绝对路径 / 相对路径</p><pre class=" language-language-bash"><code class="language-language-bash">绝对路径带/的路径就是绝对路径- 如：/etc/（波浪符)~是个特殊的绝对路径相对路径- 不带/的路径就是相对路径- 如：cd etc  这种不带/的</code></pre><p>系统目录结构</p><pre class=" language-language-bash"><code class="language-language-bash">/            #第一层次结构的根、整个文件系统层次结构的根目录。/bin/       #需要在单用户模式可用的必要命令（可执行文件）；面向所有用户，例如：cat、ls、cp，和/usr/bin类似。/boot/      #引导程序文件，例如：kernel、initrd；时常是一个单独的分区/dev/       #必要设备, 例如：, /dev/null  /dev/zero/etc/       #特定主机，系统范围内的配置文件。关于这个名称目前有争议。在贝尔实验室关于UNIX实现文档的早期版本中，/etc 被称为/etcetra 目录，这是由于过去此目录中存放所有不属于别处的所有东西（然而，FHS限制/etc存放静态配置文件，不能包含二进制文件）。自从早期文档出版以来，目录名称已被以各种方式重新称呼。最近的解释包括反向缩略语如："可编辑的文本配置"（英文 "Editable Text Configuration"）或"扩展工具箱"（英文 "Extended Tool Chest")。/etc/opt/       #/opt/的配置文件/etc/X11/       #X_Window系统(版本11)的配置文件/etc/sgml/      #SGML的配置文件/etc/xml/       #XML的配置文件/home/          #用户的家目录，包含保存的文件、个人设置等，一般为单独的分区。/lib/           #/bin/ and /sbin/中二进制文件必要的库文件。/media/         #可移除媒体(如CD-ROM)的挂载点 /lost+found     #在ext3文件系统中，当系统意外崩溃或机器意外关机，会产生一些文件碎片在这里。当系统在开机启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。当系统发生问题。可能会有文件被移动到这个目录中，可能需要用手工的方式来修复，或移到文件到原来的位置上。/mnt/       #临时挂载的文件系统。比如cdrom,u盘等，直接插入光驱无法使用，要先挂载后使用/opt/       #可选应用软件包。/proc/      #虚拟文件系统，将内核与进程状态归档为文本文件（系统信息都存放这目录下）。例如：uptime、 network。在Linux中，对应Procfs格式挂载。该目录下文件只能看不能改（包括root）/root/      #超级用户的家目录/sbin/      #必要的系统二进制文件，例如： init、 ip、 mount。sbin目录下的命令，普通用户都执行不了。/srv/       #站点的具体数据，由系统提供。/tmp/       #临时文件(参见 /var/tmp)，在系统重启时目录中文件不会被保留。/usr/       #默认软件都会存于该目录下。用于存储只读用户数据的第二层次；包含绝大多数的(多)用户工具和应用程序。/var/       #变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。如果不单独分区，有可能会把整个分区充满。如果单独分区，给大给小都不合适。</code></pre><p>常用目录</p><pre class=" language-language-bash"><code class="language-language-bash">/etc        #系统重要配置文件, 以及常用服务配置文件/var     #存放系统引导启动时产生的可变文件,文件通常动态更改的,例如: 缓存目录,日志文件/run         # 系统启动后, 运行的程序产生的运行时数据, 包括进程的pid文件,锁文件等/home        # 普通用户的主目录, 普通用户的家目录默认为/HOME/USERNAME/root      # 超级管理员的主目录, 普通用户无权操作/tmp        #存放临时文件, 一般存放超过10天以上都会自动删除,可以更改删除临时文件的期限/boot        #存放系统引导时候需要的文件/dev         #存放设备文件/usr         #安装的软件, 共享库, 重要的子目录/usr/bin    #用户命令目录/usr/sbin    #管理员命令目录/usr/local   #本地自定义安装的软件 #//注 意:在Linux7系统中, /bin, /sbin, /lib, /lib64都以软链接的形式链接到/usr/目录下,例如:/bin  --> /usr/bin/sbin --> /usr/sbinlib -> usr/liblib64 -> usr/lib64</code></pre><p>/dev</p><pre class=" language-language-bash"><code class="language-language-bash">dev定义# sda表示系统的第一块磁盘# sda1表示系统的第一块磁盘第一个分区#sda2表示系统的第一块磁盘第二个分区往后以此类推#sdb表示系统的第二块磁盘#sdb1表示系统的第二块磁盘第一个分区#sdb2表示系统的第二块磁盘二个分区dev #存放设备文件，比如硬盘，硬盘分区，光驱等 /dev/null #黑洞设备，只进不出，类似于辣鸡回收站 /dev/random #生成随机数的设备 /dev/zero #能远远不断的产生数据，类似于取款机，随时随地取钱 /dev/pts/0 #虚拟的Bash Shell终端，提供给远程用户使用，0：一个终端 1：2个终端...tty（终端设备的统称）：tty一词源于Teletypes，或teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘和显示器取代，所以现在叫终端比较合适。终端是一种字符型设备，他有多种类型，通常使用tty来简称各种类型的终端设备</code></pre><p>文件管理类</p><p>cd 切换目录</p><pre class=" language-language-bash"><code class="language-language-bash">语法： cd [目录]常用命令：cd~ 进入当前用户目录cd- 上次目录cd.. 进入上一级目录pwd 查看当前目录所在位置例：从当前目录切换到/etc/sudoers.d[root@hadoop101 ~]# cd /etc/sudoers.d/</code></pre><p>mkdir 创建</p><pre class=" language-language-bash"><code class="language-language-bash">语法： mkdir [目录名]选项：-p （递归创建目录）-v 显示过程信息例：创建一个a目录，a目录里面创建一个b目录，b目录里面创建一个c目录  [root@hadoop101 ~]# mkdir -p a/b/c序列用法;# 序列用法mkdir &#123;1..10&#125; mkdir &#123;a..z&#125; mkdir /opt/&#123;zls/&#123;1,2&#125;,oldboyedu&#125;mkdir /&#123;opt,tmp,root,home&#125;</code></pre><p>touch 创建文件</p><pre class=" language-language-bash"><code class="language-language-bash">语法:touch 文件名# 当前目录下创建xxx touch xxx # 在tmp目录下创建xxx touch /tmp/xxx # 序列 touch &#123;1..10&#125; touch xxx&#123;1..10&#125; touch &#123;1..10&#125;xxx</code></pre><p>tree 树状结构展开目录</p><pre class=" language-language-bash"><code class="language-language-bash"># 安装tree yum install -y tree # 语法 tree + 目录名 [root@localhost 19:43:13 4.2 ~]# tree 222 222 └── 333 └── 444</code></pre><p>rm 删除</p><pre class=" language-language-bash"><code class="language-language-bash">语法：rm +文件名/目录-r；递归删除-f：强制删除-i :安全提示</code></pre><p>echo</p><pre class=" language-language-bash"><code class="language-language-bash">echo命令常用的两个选项： -n 和 -e-n : 表示输出之后不换行，直接显示新行的提示符-e : 表示对于转义字符按对应的方式进行处理。使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出，若不加-e ，那么在输出时转义字符会按照普通字符进行处理。# 转义字符：用一些普通字符的组合来代替一些特殊字符，由于其组合改变了原来字符所表示的含义，因此称为转义字符\a发出警告声\b删除前一个字符\c\c后面的字符将不再输出，同一时候，输出完毕后也不换行\f换页符，光标停在原来的位置\n换行且光标移至行首\r回车符\t水平制表符，也就是Tab键\v垂直制表符\插入\字符\eEsc键\0nnn按照八进制 ASCII 码表输出字符。其中 0 为数字 0，nnn 是三位八进制数\xhh按照十六进制 ASCH 码表输出字符。其中 hh 是两位十六进制数</code></pre><p>cp：复制丶拷贝</p><pre class=" language-language-bash"><code class="language-language-bash">语法 cp [选项] 源文件 目标文件选项：-a：相当于 -v、-p、-r 选项的集合，-i：询问，如果目标文件已经存在，则会询问是否覆盖；-p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；-r：递归复制，用于复制目录；</code></pre><p>mv：移动 / 改名</p><pre class=" language-language-bash"><code class="language-language-bash">语法：mv [原文件目录][目标文件目录]常用选项：-i 安全机制，如果有相同文件，会提示你是否覆盖 -v 显示过程</code></pre><p>cat：查看文件内容</p><pre class=" language-language-bash"><code class="language-language-bash">语法：cat 选项 文件选项：-n：显示行号-E：显示文件内容行数的末尾标识$-T:将tab显示为 ^I-A：等价于 -ET#追加内容cat >> txt << EOF</code></pre><p>拓展：less/more/head/tail</p><h5 id="lessmore"><a class="markdownIt-Anchor" href="#lessmore">#</a> less/more</h5><pre class=" language-language-bash"><code class="language-language-bash">#回车 :一行一行翻页 空格 :一页一页翻页 ctrl+b:往上翻页q:退出</code></pre><h5 id="headtail"><a class="markdownIt-Anchor" href="#headtail">#</a> head/tail</h5><pre class=" language-language-bash"><code class="language-language-bash">head# 默认 查看文件默认的前10行 :head head 选项 文件名 -n :选填数字-1 #查看第一行 -2 #查看前两行 -5 #前五行tail# 默认 查看文件的后10行 -n number -f ： 实时追踪文件tail -1 查看文件末行 tail -2 查看文件最后两行tail -f：实时追踪变化# 例：查看文件txt的变化[root@hadoop100 ~]# tail -f like </code></pre><p>上传 / 下载：rz  sz</p><pre class=" language-language-bash"><code class="language-language-bash">首先安装：yum install -y lrzszrz 上传到linuxsz 下载到windows#wget + 文件网址链接也可下载wget + URL</code></pre><h4 id="whichwhereis"><a class="markdownIt-Anchor" href="#whichwhereis">#</a> which/whereis</h4><pre class=" language-language-bash"><code class="language-language-bash">语法：which [命令]# 找命令的绝对路径[root@Hadoop102 ~]# which touch/usr/bin/touch</code></pre><p>排序 / 去重：sort /uniq</p><pre class=" language-language-bash"><code class="language-language-bash">语法：sort 选项 文件# 选项-t 指定分隔符-k 分割区域进行排序-n 按照数值的大小排序-r 倒叙  #//默认顺序uniq#uniq必须配合sort使用-c 统计去重后的每个值的数量[root@localhost ~]# cat 1.txt | sort | uniq -c6 1236 abc</code></pre><p>截取：cut</p><pre class=" language-language-bash"><code class="language-language-bash">语法：cut [选项] [文件名]选项：-d 指定分隔符-f 指定第几列-c 按字符集截取例：配合grep截取ip[root@hadoop103 ~]# ifconfig ens33 | grep 'inet'        inet 192.168.16.13  netmask 255.255.255.0  broadcast 192.168.16.255[root@hadoop103 ~]# ifconfig ens33 | grep 'inet' | cut -d ' ' -f10192.168.16.13</code></pre><p>tr：临时替换字符</p><pre class=" language-language-bash"><code class="language-language-bash">#将逗号替换成空格tr ',' ' 'tr一换一‘ 换 空格“ 换 空格例：利用tr替换计算权限[root@hadoop101 ~]#lltotal 0drwxr-xr-x. 2 root root 6 Apr  6 11:49 jiujiu-rw-r--r--. 1 root root 0 Apr  6 11:49 like[root@hadoop101 ~]#ll | tr 'rwx-' '4210' | awk -F '' 'NR==2&#123;print 2+$3+$4""$5+$6+$7""$8+$9+$10&#125;' 755</code></pre><p>wc：统计</p><pre class=" language-language-bash"><code class="language-language-bash"># 统计-l 统计行数[root@localhost ~]# wc -l /etc/services11176 /etc/services-c 统计字节[root@localhost ~]# wc -c /etc/services670293 /etc/services-w 统计单词数[root@localhost ~]# wc -w /etc/services61033 /etc/services-L 找出文件中的最长一行，统计元素个数[root@hadoop102 ~]# cat 991231234123456123345612433454123456789[root@hadoop102 ~]# cat 99| wc -L9</code></pre><p>find 查找</p><p>按名字查找</p><pre class=" language-language-bash"><code class="language-language-bash">语法： find 路径 选项 参数-name# 在根号底下找名字为1.txt的文件或者目录find / -name 1.txt# 不区分大小写[root@pkq ~]# find /root -name 1.txt/root/1.txt[root@pkq ~]# find /root -iname 1.txt/root/1.txt/root/1.TXT# 找.txt结尾的find / -name "*.txt"</code></pre><p>按照文件类型</p><pre class=" language-language-bash"><code class="language-language-bash">find 路径 选项 参数-name# 在根号地下找名字为1.txt的文件或者目录find / -name 1.txt# 不区分大小写[root@pkq ~]# find /root -name 1.txt/root/1.txt[root@pkq ~]# find /root -iname 1.txt/root/1.txt/root/1.TXT# 找.txt结尾的find / -name "*.txt"-typed 目录f 文件 filel 链接文件s socket 套接字文件p 管道文件b 块设备 磁盘    c 块设备 设备# root下找文件find /root -type f# root下找目录find /root -type d# 根号下找socket文件find / -type s# 根号下找c设备文件find / -type c# 根号下找块设备文件find / -type b# 根号下找链接文件find / -type l# 根号下找管道文件find / -type p</code></pre><p>按照用户查找</p><pre class=" language-language-bash"><code class="language-language-bash"># 根据文件用户查找-user# 查找home下属主是baolong[root@pkq ~]# find /home -user baolong/home/baolong/home/baolong/.bash_logout-group# 查找home下属组是baolong[root@pkq ~]# find /home -group baolong/home/baolong/home/baolong/.bash_logout/home/baolong/.bash_profile[root@pkq ~]# find /home -user baolong -o -user oldboy1/home/baolong/home/baolong/.bash_log[root@pkq /home/baolong]# find /home -user baolong -a -group oldboy1/home/baolong/2# 没有属主 属组find /home/ -nouserfind /home/ -nogroup</code></pre><p>按照时间查找</p><pre class=" language-language-bash"><code class="language-language-bash">stat ：查看目录或者文件改变情况-mtime Modified time 是在写入文件时随文件内容的更改而更改的# 修改内容的命令都会刷新mtime 和 ctime-atime Access time 是在读取文件或者执行文件时更改# 类似 cat vim命令都会刷新atime-ctime Change time 是在写入文件、更改所有者、权限或链接设置# 修改内容的命令都会刷新mtime 和 ctime 只有修改文件属性的时候ctime才会单独刷新时间戳## 按照mtime时间查找# +7 查找七天之前的文件，不包含当天find / -type f -name '*.txt' -mtime +7# -7 查找最近7天的文件，包含当天find / -type f -name '*.txt' -mtime -7# 7 查找不包含当天的，往前数第7天find / -type f -name '*.txt' -mtime 7</code></pre><p>按照大小查找</p><pre class=" language-language-bash"><code class="language-language-bash">-size+5M 查找大于5M的-5M 查找小于5M的5M 精确查找5M# 查找根号地下小于5M 大于1Mfind / -size -5M -a -size +1Mfind / -type f -size 11k</code></pre><h5 id="find按照深度查找"><a class="markdownIt-Anchor" href="#find按照深度查找">#</a> find 按照深度查找</h5><pre class=" language-language-bash"><code class="language-language-bash">-maxdepth # 查找一级目录find /etc/ -type d -maxdepth 1# 查找二级目录find /etc/ -type d -maxdepth 2# 查找三级目录find /etc/ -type d -maxdepth 3</code></pre><p>find 按照权限查找</p><pre class=" language-language-bash"><code class="language-language-bash">-perm[root@pkq ~]# find -perm 644./.bash_logout./.bash_profile./.cshrc./.tcshrc./.bashrc[root@pkq ~]# find ./ -perm 600./.bash_history./1.txt./.viminfo# 精确查找-perm 222# 模糊匹配-后面的对应权限-perm -222#find /home -perm /442r rw rwx rr rw rwx rw wx rw rwx//包含set uid[root@zls ~]# find /usr/sbin -perm -4000 -ls//包含set gid[root@zls ~]# find /usr/sbin -perm -2000 -ls//包含sticky[root@zls ~]# find /usr/sbin -perm -1000 -ls</code></pre><p>find 的动作（了解，并不用）</p><table><thead><tr><th><strong>动作</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-print</td><td>打印查找到的内容（默认）</td></tr><tr><td>-ls</td><td>以长格式显示的方式打印查找到的内容</td></tr><tr><td>-delete</td><td>删除查找到的文件（仅能删除空目录）</td></tr><tr><td>-ok</td><td>后面跟自定义 shell 命令（会提示是否操作</td></tr><tr><td>-exec</td><td>后面跟自定义 shell 命令（标准写法 - exec  ;</td></tr></tbody></table><p>文件属性 / 权限修改</p><p>文件属性</p><pre class=" language-language-bash"><code class="language-language-bash">-rw-r--r--. 1 root root 0 Mar 16 10:14 1- 文件类型rw-r--r--. 文件权限1 硬链接数量root 属主root 属组0 文件大小Mar 16 10:14 时间戳</code></pre><p>文件类型</p><pre class=" language-language-bash"><code class="language-language-bash">ls -l 文件名 //看第一个字符格式 说明- 普通文件(文本, 二进制, 压缩, 图片, 日志等)d 目录文件b 设备文件(块设备)存储设备硬盘 /dev/sda1, /dev/sda2c 设备文件(字符设备)打印机，终端 /dev/tty1, /dev/zeros 套接字文件, 进程间通信(socket)p 管道文件l 链接文件</code></pre><p>查看磁盘空间 /inode/block</p><p>inode</p><pre><code>inode包含文件的元信息，具体来说有以下内容：* 文件的字节数　　* 文件拥有者的User ID　　* 文件的Group ID　　* 文件的读、写、执行权限　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。　　* 链接数，即有多少文件名指向这个inode　　* 文件数据block的位置</code></pre><p>block</p><pre><code>1.Block的概念block也就是通常所说的代码块，block可以用来存储代码。block用来封装和存储代码是和函数差不多的，block可以在任何时候执行。block和函数有以下相似性：保存代码；有返回值；有形参；调用方式一样。</code></pre><pre class=" language-language-bash"><code class="language-language-bash"># df 查看磁盘空间-h :以人性化的显示-i 查看inode空间例：[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda3 19G 1.2G 18G 7% /devtmpfs 476M 0 476M 0% /devtmpfs 487M 0 487M 0% /dev/shmtmpfs 487M 7.7M 479M 2% /runtmpfs 487M 0 487M 0% /sys/fs/cgroup/dev/sda1 497M 120M 378M 25% /boottmpfs 98M 0 98M 0% /run/user/0#查看inode例：[root@localhost ~]# df -iFilesystem Inodes IUsed IFree IUse% Mounted on/dev/sda3 9704960 27494 9677466 1% /devtmpfs 121773 373 121400 1% /devtmpfs 124487 1 124486 1% /dev/shmtmpfs 124487 712 123775 1% /runtmpfs 124487 16 124471 1% /sys/fs/cgroup/dev/sda1 256000 326 255674 1% /boottmpfs 124487 1 124486 1% /run/user/0</code></pre><p>软链接 / 硬链接</p><pre class=" language-language-bash"><code class="language-language-bash"># 创建软连接的命令ln  链接 创建链接文件选项：-s  软 创建软链接ln -s 源文件 链接文件地址名字# 例子ln -s 2.txt amusitelanghuixuanamusitelangpaoln -s 2.txt /tmp/amusitelang# 软连接受到源文件的影响ln -s web.txt web.log# 删除源文件[root@localhost ~]# rm -fr web.txt# 软连接文件失效[root@localhost ~]# cat web.logcat: web.log: No such file or directory #链接失效报错## 特性1.硬链接和源文件的inode号一致2.硬链接不受源文件影响，即使源文件删除，也不影响硬链接3.硬链接不能针对目录创建硬链接4.修改源文件，硬链接也会同步更新，修改硬链接，源文件也会同步更新5.一个新创建的目录会有两个硬链接，一个是目录本身，另一个是影藏的当前目录</code></pre><table><thead><tr><th>区别</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>命令</td><td>ln</td><td>ln -s</td></tr><tr><td>对象</td><td>只能对文件创建硬链接</td><td>普通文件丶目录</td></tr><tr><td>是否受源文件影响</td><td>否</td><td>是</td></tr><tr><td>inode 号</td><td>相同</td><td>不同</td></tr><tr><td>跨分区创建</td><td>不能</td><td>可以</td></tr><tr><td>是否影响源文件</td><td>是</td><td>是</td></tr></tbody></table><p>用户 sudo 提权</p><p>sudo 将一个普通用户的身份提升至 root 权限</p><pre class=" language-language-bash"><code class="language-language-bash">## 第一种提权# visudo:100行左右root ALL=（ALL） ALLuser ALL=（ALL） ALL# 提权完毕后普通用户执行命令之前要加 sudo[baolong@localhost root]$ sudo ls -l# 普通用户免密baolong ALL=(ALL) NOPASSWD:ALL （免密）# 讲解# 用户名 所有主机      所有命令的执行权限root    ALL=（ALL）   ALL# 第二种提权针对多个用户visudo108附近%wheel ALL=(ALL) ALL将用户加入组usermod oldboy1 -G wheel## sudo不认识别名，只能走系统命令Host_Alias HOST = localhost web01 web02User_Alias OLDBOY = oldboy3,oldboy4Cmnd_Alias COM = /bin/cp,/bin/mv,/bin/cat</code></pre><p>权限的管理</p><pre class=" language-language-bash"><code class="language-language-bash">-rw-r--r--. 1 root root 99 Mar 22 11:34 1.txtr 读 4w 写 2x 执行 1- 没有权限 0# 计算权限  //利用tr替换计算ll | tr 'rwx-' '4210' | awk -F '' 'NR==2&#123;print $2+$3+$4""$5+$6+$7""$8+$9+$10&#125;'644# 优化计算权限stat -c %a 文件名755</code></pre><p>权限的修改：</p><pre class=" language-language-bash"><code class="language-language-bash">chmod# 修改权限user 属主group 属组other 其他用户a  所有u 属主g 数组o 其他用户# =chmod u=rwx 1.shchmod g=rwx 1.shchmod o=rwx 1.sh# -chmod u-w 1.shchmod g-r 1.shchmod o-x 1.sh# +chmod a+r 1.shchmod a+w 1.shchmod a+x 1.sh# a 所有 （+ - =）chmod a-r 1.sh # a+/a=chmod a-w 1.sh # a+/a=chmod a-x 1.sh # a+/a=# 数字chmod 755 1.sh   -rwxr-xr-xchmod 644 1.sh   -r-wr--r--chmod 000 1.sh   ----------</code></pre><p>权限对文件的影响：</p><pre class=" language-language-bash"><code class="language-language-bash">r   #文件只能读取w   #任何编辑命令都可以写入x   #对于普通用户来说，还是做不了事 ，必须配合r去使用rw  #可读可写，正常的使用vim编辑，但是不能执行rx  #可读，可执行，但是不能编辑wx  #可写 可执行 不可读取rwx #可读可写可执行</code></pre><p>权限对目录的影响：</p><pre class=" language-language-bash"><code class="language-language-bash"># 注意：目录在只有单权限情况下啥也做不了r  #能看见目录下的文件，但是看不了目录下文件的详细信息w  #啥也做不了x  #啥也做不了rx #才能查看目录下的文件wx #读取不了目录里的文件，但是能创建文件/创建目录/删除目录/删除文件  不能用*代替rwx #可读可写可执行，可以创建，删除 移动 复制 文件/目录</code></pre><p>修改文件属主和属组</p><pre class=" language-language-bash"><code class="language-language-bash">chown# 修改属主和属组  //目录和文件的chown baolong:baolong xxxchown root:root xxx# 递归-R# 只修改属主chown root xxx# 只改属组chown :baolong xxx#递归修改chown -R baolong:baolong xxx[root@pkq /opt]# ll xxx/total 0-rw-r--r--. 1 baolong baolong 0 Mar 23 18:57 1.txt-rw-r--r--. 1 baolong baolong 0 Mar 23 19:04 2.txt-rw-r--r--. 1 baolong baolong 0 Mar 23 19:04 3.txt-rw-r--r--. 1 baolong baolong 0 Mar 23 19:04 4.txt</code></pre><p>特殊权限</p><p>SetUID</p><pre class=" language-language-bash"><code class="language-language-bash">setuid 特殊权限授权# 基本权限r 读w 写x 执行- 没有权限-rwsr-xr-x. 1 root root 27832 Jun 10 2014 passwd4000# 授权方法chmod 4755 filechmod u + schmod u = s# 特性如果原本没有x权限 授权为setuid 会是大写 S如果原本有x权限 授权为setuid 会是小写 su + su = s## 为什么普通用户可以修改密码1） 使用了passwd命令2）passwd命令文件在属主位上有个s权限 原本的x变成了s3）s权限在属主位，又叫做setuid权限 setUID#4）作用 普通用户在使用有setuid权限的文件或者命令的时候，会以该文件的属主身份去运行！！！！！</code></pre><p>setgid</p><p>将目录设置为 SGID 后，如果在该目录下创建文件，都将与该目录的所属组保持一致</p><pre class=" language-language-bash"><code class="language-language-bash"># 授权方法chmod 2755 directorychmod g+s directory如果原本没有x权限 授权为setuid 会是大写 S如果原本有x权限 授权为setuid 会是小写 s</code></pre><p>sticky</p><pre class=" language-language-bash"><code class="language-language-bash">ll -d /tmpdrwxrwxrwt. 8 root root 127 Mar 23 16:44 .1 带有粘滞位的目录下的所有文件，谁都可以读，写2.带有粘滞位的目录下的文件只有属主才能删除自己的文件，其他普通用户无法删除属主不是自己的文件3.带有粘滞位的目录 只有root能删## 授权方法chmod o+tchmod 1777 directorysbit权限数字是1000如果原本有x权限 授权特殊sbit后 t如果原本没有x权限 授权特殊sbit后 T</code></pre><p>vim 的三种模式</p><p>命令模式</p><pre class=" language-language-bash"><code class="language-language-bash"># 光标跳转gg 跳转文本行首G 跳转至文本行末ngg #n代表数# 复制黏贴yy 复制你光标所在的一整行nyy #n代表数复制光标所在行开始n行 #n代表数p 将复制的内容，黏贴在光标所在行的下一行 （小写）P 将复制的内容，黏贴在光标所在行的上一行 （大写）# 剪切dd 删除或者剪切 可以通过p黏贴5dd/d5d 删除/剪切 数字dG 删除光标所在的行至文本末尾x 删除光标所在的字符 （小写）X 删除光标所在前的一个字符 （大写）# 撤销u 撤销上一步操作r 替换贯标所在的字符R 持续替换知道按下ESCctrl + r 恢复撤销，回滚</code></pre><p>编辑模式</p><pre class=" language-language-bash"><code class="language-language-bash">i 在光标前进入编辑模式I 进入编辑模式，光标跳转只行首a 光标往后退一格，进入编辑模式A 进入编辑模式，光标跳转只行末o 跳转至光标下一行进入编辑模式O 跳转至光标上一行进入编辑模式（大写）s 吧光标所在的字符删除，并进入编辑模式S 删除整行并进入编辑模式(大写)</code></pre><p>底行模式</p><pre class=" language-language-bash"><code class="language-language-bash">:wq 保存退出:w 保存:q 退出:wq! 强制保存退出:q! 强制退出:w! 强制保存:x 保存退出shift + zz 保存退出：number #数字！！：1 跳转只第一行</code></pre><p>底行模式查找 / 替换：</p><pre class=" language-language-bash"><code class="language-language-bash">查找：/关键字#替换：%s/root/xxx/gs （search） 查询g （global） 全局% 代替所有行:set nu 显示行号:set ai 自动缩进:set ic 不区分大小写:set list 显示制表符吗，显示结尾符号和TAB符号# 取消:set no（ai nu list ic）# 取消高亮nohl</code></pre><p>视图模式：</p><pre class=" language-language-bash"><code class="language-language-bash">ctrl + v进入试图模式# 集体注释ctrl + vshift +g (G)移动至末行shift +i (i)光标移至行首进入编辑模式shift +3 (#)ESC ESC# 群体取消注释x## 多开文件在同一个窗口打开多个文件vim -o  finename1 finename2 ：水平垂直编辑vim -O finename1 finename2 ：水平垂直编辑文件对比：vimdiff   finename1 finename2(1)先使用vi打开一个文件，例如vi file1(2)分割窗口打开另外的文件:sp file2 //水平分割打开第二个文件，sp=[split](https://so.csdn.net/so/search?q=split&spm=1001.2101.3001.7020):vsp file2 //垂直分割打开第二个文件，vsp=vsplit:vs 也可ctrl+w：切换两个编辑器</code></pre><p>用户管理</p><pre class=" language-language-bash"><code class="language-language-bash">用户指的是能够正常登录Linux或windows系统那Linux与windows系统的用户有什么区别？本质都是登录系统的，只不过Linux支持多用户同时登录，windows默认不支持，但是修改组策略的情况下也是可以多用户登录的#用户的作用：登录用户用户用来运行程序每一个目录或者文件，都有指定的用户的权限程序的运行用户要与程序调用的用户目录权限相同</code></pre><p>用户文件信息释明：</p><pre class=" language-language-bash"><code class="language-language-bash">查看用户：id [用户名]或者cat /etc/passwd/etc/passwd存放用户信息的文件jiujiu:x:1000:1000:jiujiu:/home/jiujiu:/bin/bash显示信息说明：第一列 用户名第二列 密码的占位符第三列 用户的id UID root 0第四列 用户组的id gid root 0第五列 对用户的表述第六列 用户的家目录第七列 用户登录的bash/etc/shadow存放用户密码的文件jiujiu:!$6$H8K7zklpu0.hFi4k$J0jjVuK74pZXZfXOxtMKh9i/ZkB64mI4cDp1ST2w6TheCI5gZL2JH.4VQeiBsXYIYFS6wZognujdISZRRpVfv1::0:99999:7:::显示信息说明：第一列 用户名第二列 加密后的密码，！！/*代表没有密码第三列 上一次更改密码的时间，是从1970年开始算第四列 密码最少使用天数 0代表无限第五列 密码最长使用天数 99999代表无限第六列 密码到期前7天提示需要修改密码第七列 密码过期后N天强制更改密码第八列 账户失效时间，也是从1970年开始算第九列 为空</code></pre><p>用户 uid 的说明：</p><table><thead><tr><th>0</th><th>超级管理员 (拥有最高权限)</th></tr></thead><tbody><tr><td>1-200</td><td>系统用户，由系统分配给系统进程使用</td></tr><tr><td>201-999</td><td>系统用户，用来运行服务账户，不需要登陆系统 (动态分配)</td></tr><tr><td>1000+</td><td>常规普通用户</td></tr></tbody></table><p>1）增</p><pre class=" language-language-bash"><code class="language-language-bash">useradd / adduser-u 指定用户的uid例：useradd -u 10086 xyz-g 指定用户的组例：useradd -g haige xyz # xyz是新用户  组必须是已存在的组-d 指定用户家目录例：useradd -d /tmp/ zxc-c 指定用户注释信息例：useradd -c'for linux' mmm-M 不创建家目录例：useradd -M jkl-s 指定用户默认shell例：useradd -s /sbin/nologin mnb-G 指定用户加入附加组例：useradd -G  要加入的组   新用户-r 创建系统用户</code></pre><p>2）删：</p><pre class=" language-language-bash"><code class="language-language-bash">userdel 用户名-r 删除用户的同时删除用户的家目录包括邮箱信息</code></pre><p>3）改</p><pre class=" language-language-bash"><code class="language-language-bash">usermod# 参数的用户名是必须创建过的-u 修改用户的uid例：usermod -u 2000 xiaohei-g 修改gid gid 组必须存在  #修改用户本身基本组例：usermod -g  组id  需修改的用户[root@hadoop103 ~]# id jiujiuuid=1000(jiujiu) gid=1000(jiujiu) groups=1000(jiujiu)[root@hadoop103 ~]# cat /etc/group |tail -1like:x:6666:[root@hadoop103 ~]# usermod -g 6666 jiujiu[root@hadoop103 ~]# id jiujiuuid=1000(jiujiu) gid=6666(like) groups=6666(like),1000(jiujiu)-G 修改附加组 组必须存在  #添加附加组例：usermod -G 被加入的组   要加入的组[root@hadoop103 ~]# id jiujiuuid=1000(jiujiu) gid=1000(jiujiu) groups=1000(jiujiu)[root@hadoop103 ~]# usermod -G like jiujiu[root@hadoop103 ~]# id jiujiuuid=1000(jiujiu) gid=1000(jiujiu) groups=1000(jiujiu),1111(like)-c 修改注释信息例：usermod -c 'heideyipi' xiaohei-s 修改用户的登录shell例：usermod -s /sbin/nologin xiaohei-m 迁移家目录 要配合-d例：usermod -d /opt/hei -m xiaohei-l 修改用户的登录名例：usermod -l zhenniubi niubi## 创建用户会默认创建和用户同名的组</code></pre><p>4）查：</p><pre class=" language-language-bash"><code class="language-language-bash">[root@localhost /home]# id xiaolvid: xiaolv: no such user[root@localhost /home]# id xiaoheiuid=10096(xiaohei) gid=10096(xiaohei) groups=10096(xiaohei)cat /etc/passwd</code></pre><p>用户创建配置文件释明：</p><pre class=" language-language-bash"><code class="language-language-bash">cat /etc/login.defs过滤掉所有注释行和空行后剩余信息说明：[root@hadoop103 ~]# cat /etc/login.defs | egrep -v '^$|^#.*$'# 创建用户的时候会创建用户相关邮件所在的路径MAIL_DIR/var/spool/mailPASS_MAX_DAYS99999PASS_MIN_DAYS0PASS_MIN_LEN5PASS_WARN_AGE7UID_MIN                  1000UID_MAX                 60000SYS_UID_MIN               201SYS_UID_MAX               999GID_MIN                  1000GID_MAX                 60000SYS_GID_MIN               201SYS_GID_MAX               999CREATE_HOMEyesUMASK           077USERGROUPS_ENAB yesENCRYPT_METHOD SHA512 MAIL_DIR /var/spool/mail# 密码最长使用天数PASS_MAX_DAYS 99999# 密码最少使用天数PASS_MIN_DAYS 0# 密码最少长度PASS_MIN_LEN 5# 密码到期前7天会提醒PASS_WARN_AGE 7# 普通用户最小uidUID_MIN 1000# 普通用户最大uidUID_MAX 60000# 系统用户最小uidSYS_UID_MIN 201# 系统用户最大uidSYS_UID_MAX 999# 普通用户最小gidGID_MIN 1000# 普通用户最大gidGID_MAX 60000# 系统用户最小gidSYS_GID_MIN 201# 系统用户最大gidSYS_GID_MAX 999# 创建家目录CREATE_HOME yes# umaskUMASK 077# 创建用户的时候，同时创建该用户的同名用户组USERGROUPS_ENAB yes# 密码加密格式 SHA512ENCRYPT_METHOD SHA512--------------------------------------------------------------------------------如果用户创建配置文件中USERGROUPS_ENAB 结果为no时，则会读取下列配置文件/etc/default/useradd说明：# useradd defaults file# 组的gid 100GROUP=100# 家目录的位置HOME=/home# 账号过期后都不会停止使用 -1=不开启INACTIVE=-1# 账号不过期EXPIRE=# 指定用户创建时的shellSHELL=/bin/bash# 普通用户的环境变量储存SKEL=/etc/skel# 创建用户是，是否创建邮件文件CREATE_MAIL_SPOOL=yes</code></pre><p>密码管理设置信息：</p><pre class=" language-language-bash"><code class="language-language-bash"># 给当前登录用户设置密码passwd# 给普通用户设置密码passwd user  //user表示用户名# root用户设置密码可以无视密码长度# 普通用户设置密码必须遵守8位数# 交互类似挤牙膏，动一下挤一下# 免交互可以免除交互，不需要一个个点# 生成密码yum install -y expectmkpasswd -l 10 -d 3 -c 4 -C 2 -s 1-l 密码长度-d 密码数字个数-c 小写英文个数-C 大写英文个数-s 特殊符号#拓展  用echo给用户设置密码echo 1 | passwd --stdin user2例：建立一个新用户user2并把它加入到root组中，设置user2的密码为：1[root@hadoop101 ~]#useradd -g root user2 && echo 1 | passwd --stdin user2</code></pre><p>组管理信息：</p><pre class=" language-language-bash"><code class="language-language-bash">cat /etc/group# 组信息canglong:x:10103:1 组名2 密码占位符3 gid4 附加组，基本成员不显示gcat /etc/gshadow# 组密码信息haige:!::zzz,xbwl1 组名2 组密码 ！为空3 组管理员4 仅显示附加组成员，不显示基本成员</code></pre><p>组创建</p><p>1）增</p><pre class=" language-language-bash"><code class="language-language-bash">-g：指定用户组gidgroupadd jiujiugroupadd -g 666 jiujiu# 创建系统组，gid从201-999-r：创建系统组[root@zls ~]# groupadd -r sys_group[root@zls ~]# tail -1 /etc/groupsys_group:x:665</code></pre><p>2）改</p><pre class=" language-language-bash"><code class="language-language-bash">groupmod# 修改原有组的gidgroupmod -g 777 jiujiu# 修改组名groupmod -n like jiujiu</code></pre><p>3）删</p><pre class=" language-language-bash"><code class="language-language-bash">语法：groupdel 组名注：如果组下面有其他用户，则删不了，要把其他用户移出去在删</code></pre><p>4）查</p><pre class=" language-language-bash"><code class="language-language-bash">cat /etc/group</code></pre><p>输入和输出</p><table><thead><tr><th><strong>名称</strong></th><th><strong>文件描述符</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>stdin</td><td>0</td><td>标准输入</td></tr><tr><td>stdout</td><td>1</td><td>标准输出</td></tr><tr><td>stderr</td><td>2</td><td>错误输出</td></tr><tr><td>文件名</td><td>3+</td><td></td></tr></tbody></table><p>重定向的概念</p><pre class=" language-language-bash"><code class="language-language-bash">将原本要输出到屏幕的数据信息，重新定向到指定的文件中。比如：每天凌晨定时备份数据，希望将备份数据的结果保存到某个文件中。这样第二天通过查看结果文件，就知道昨天备份数据是成功，还是失败。</code></pre><p>命令返回值</p><pre class=" language-language-bash"><code class="language-language-bash"># 如何判断上一条命令的执行是否成功echo $?返回值是0 就代表上一条命令执行成功返回值如果不是0 就代表上一条命令不成功</code></pre><p>输出重定向</p><p>重定向：改变标准输入、标准输出的方向的就是重定向</p><table><thead><tr><th><strong>类型</strong></th><th>操作符</th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>标准覆盖输出重定向</td><td>1&gt;</td><td>将命令的执行结果输出到指定的文件中，而不是直接显示在屏幕上</td></tr><tr><td>标准追加输出重定向</td><td>&gt;&gt;</td><td>将命令执行的结果追加输出到指定文件</td></tr><tr><td>错误覆盖输出重定向</td><td>2&gt;</td><td>将程序的错误结果输出到执行的文件中，会覆盖源文件内容</td></tr><tr><td>错误追加输出重 定向</td><td>2&gt;&gt;</td><td>将程序输出的错误结果以追加的方式输出到指定文件中，不会覆盖源文件</td></tr><tr><td>标准输入重定向</td><td>&lt;&lt;</td><td>将命令中接收输入的途径由默认的键盘更改为指定的文件</td></tr></tbody></table><p>标准输出追加重定向</p><pre class=" language-language-bash"><code class="language-language-bash">[root@pkq ~]# echo hello world >> 1.txt[root@pkq ~]# cat 1.txtcat: asdadasd: No such file or directoryhello world</code></pre><p>错误输出重定向</p><pre class=" language-language-bash"><code class="language-language-bash">ll /asdasdasd 2> 1.txt</code></pre><p>正确和错误都输出到相同位置</p><pre class=" language-language-bash"><code class="language-language-bash">find / -name "*.conf" &>ab</code></pre><p>输出重定向</p><pre class=" language-language-bash"><code class="language-language-bash">dd if=/dev/zero of=/root/1.txt bs=1M count=20dd bs=1K count=1024 </dev/zero > /root/4.txt</code></pre><p>管道符 ：|</p><pre class=" language-language-bash"><code class="language-language-bash"># 将/etc/passwd以uid排序并展示前10行[root@pkq ~]# sort -t ':' -k3 -n /etc/passwd|head# 统计/etc/passwd的所有shell类型[root@pkq ~]# awk -F: '&#123;print $NF&#125;' /etc/passwd | sort | uniq -c106 /bin/bash1 /bin/sync1 /sbin/halt</code></pre><p>分流技术：tee</p><pre class=" language-language-bash"><code class="language-language-bash"># 分流到文件ip addr |grep 'inet ' |tee ip.txt |awk -F"/" '&#123;print $1&#125;' |awk '&#123;print $2&#125;'# 分流到终端ip addr |grep 'inet ' |tee /dev/pts/0 |awk -F"/" '&#123;print $1&#125;' |awk '&#123;print $2&#125;'</code></pre><p>xargs</p><p>将原本没有标准输入的命令，收到 xargs 的标准输入中，</p><p>在传递给后面的命令处理</p><pre class=" language-language-bash"><code class="language-language-bash">-I 将数据保存在&#123;&#125;之中， 后面的命令可以直接调用&#123;&#125;： find /root/ -name '*.sh' | xargs -I &#123;&#125; cp &#123;&#125; /opt/-i 默认&#123;&#125;保存结果</code></pre><pre class=" language-language-bash"><code class="language-language-bash">参数说明参数参数说明-0, --null项目之间用null分隔，而不是空格。禁用引号和反斜杠处理-a, --arg-file=FILE从文件中读入作为 stdin-d, --delimiter=CHARACTER自定义分隔符-E ENDxargs分析到含有flag这个标志的时候就停止-e [END], --eof[=END]注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。–help打印帮助选项-I R将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;，可以用 &#123;&#125; 代替-i,–replace=[R]将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;，可以用 &#123;&#125; 代替-L,-l, --max-lines=MAX-LINES如果标准输入包含多行，-L参数指定多少行作为一个命令行参数。-l从标准输入一次读取 num 行送给 command 命令。-n, --max-args=MAX-ARGS后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的-P, --max-procs=MAX-PROCSxargs默认只用一个进程执行命令。如果命令要执行多次，必须等上一次执行完，才能执行下一次，0表示不限制进程数。-p, --interactive当每次执行一个argument的时候询问一次用户。–process-slot-var=VAR在子进程中设置环境变量var过程-r, --no-run-if-empty当xargs的输入为空的时候则停止xargs，不用再去执行了。-s, --max-chars=MAX-CHARS命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。–show-limits显示命令行长度的限制-t, --verbose在执行之前详细打印命令–version打印版本号信息-x, --exitexit的意思，主要是配合-s使用</code></pre><p>LInux 中常见的压缩包类型</p><p>***** 号常用</p><table><thead><tr><th>用法格式</th><th>使用工具</th></tr></thead><tbody><tr><td>.zip</td><td>zip 压缩工具    *</td></tr><tr><td>.gz</td><td>gzip 压缩工具，只能压缩文件，会删除源文件（通常配合 tar 使用） *</td></tr><tr><td>.bz2</td><td>bzip2 压缩工具，只能压缩文件，会删除源文件（通常配合 tar 使用）</td></tr><tr><td>.tar.gz</td><td>先使用 tar  z 命令归档打包，然后使用 gzip 压缩          *</td></tr><tr><td>.tzr.bz2</td><td>先使用 tar  j 命令归档打包，然后使用 bzip 压缩</td></tr><tr><td>.tar.xz</td><td></td></tr></tbody></table><p>gzip</p><pre class=" language-language-bash"><code class="language-language-bash"># 如果没有该命令，安装gzipyum install -y gzip# 准备文件touch file&#123;1..10&#125;# 语法gzip 选项 文件名...gzip [option] [file...]-r 指定目录，将目录下的所有文件都单独压缩成gz包 #（目录不会变压缩包，目录下的所有文件会变成压缩包）-d 解压#例题：压缩file10文件gzip file10# gzip 特性gzip压缩文件 ，源文件消失gzip压缩文件，每个文件都是单独的压缩包gzip默认只能压缩文件，不能压缩目录#  zcat能查看压缩包里的文件内容  当解压的时候，源文件出来，压缩包会消失</code></pre><p>zip</p><pre class=" language-language-bash"><code class="language-language-bash"># 安装zip  unzipyum install -y zip unzip## 语法zip [选项] [压缩包名] [文件名...]-r 递归处理，把目录下所有文件都压缩进去# 特性zip打包，保留源文件unzip解压压缩包，压缩包不会消失zip可以打包目录，但是不加-r纯粹打包空目录zip解压 unzip 默认解压到当前目录unzip -d 可以解压到其他指定的路径下</code></pre><p>tar</p><pre class=" language-language-bash"><code class="language-language-bash">## 语法tar 选项 文件名## 选项c 给文件做归档f 后面必须接文件名z 以gzip格式打包v 显示过程x 解压归档文件C 解压指定的目录t 列出归档文件里的文件列表j 使用bzip2压缩归档后的文件(.tar.bz2)J 使用xz压缩归档后的文件(tar.xz)X 排除多个文件(写入需要排除的文件名称)h 打包软连接P 连带绝对路径打包## 了解即可--hard-dereference   打包硬链接--exclude  在打包的时候写入需要排除文件或目录# 万能解压tar xf# 打包.xz的包tar Jcf xxx.tar.xz xxx （小写j）# 打包.bz2的包tar jcf xxx.tar.xz xxx （大写J）# 选项无论怎么组合 f后面必须加文件名 f必须放最后！！！！！！！# tar有个安全机制，如果是以绝对路径打包，则会删除前面的/# 为了避免这种情况出现避免解压开的时候覆盖原目录内容，要压缩那个目录，就去这个目录的上一级，使用相对路径# tar解压后，直接覆盖相同文件，不会提示是否覆盖# 排除单个文件tar zcf log.tar.gz --exclude=10.log --exclude=9.log /opt/# 使用大X排除文件，把想要排除的文件写入文件夹，在打包的时候X后面跟上要排除的文件夹名即可tar zcf log.tar.gz -X paichu opt/#常用打包与压缩组合打包/压缩：czf： 打包tar.gz格式cjf： 打包tar.bz格式cJf： 打包tar.xz格式解压：zxf： 解压tar.gz格式jxf： 解压tar.bz格式xf：  自动选择解压模式tf：   查看tar压缩包内容</code></pre><p>RPM 全称 RPM Package Manager 缩写，由红帽开发用于</p><p>软件包的安装，升级卸载与查询</p><p><img src="https://s2.loli.net/2023/07/07/DSWPAi9QK2Zat5j.png" alt=""></p><pre class=" language-language-bash"><code class="language-language-bash">#安装包祥明tree-1.6.0-10.el7.x86_64.rpmtree # 软件名称1.6.0 #版本号10 #发布次数el7 #使用系统版本（CentOS7.RedHalt7）向下兼容x86_64 #系统平台 64位 32位rpm #包后缀名</code></pre><p>linux 中软件的安装方式</p><pre class=" language-language-bash"><code class="language-language-bash">rpm安装 已经编译好了的源码包，下载好了之后，直接使用rpm命令管理源码安装 先编译，将源代码翻译成系统能认识的软件，再去安装二进制安装 绿色软件（免安装）</code></pre><p>rpm 包的获取途径</p><pre><code>.RedHat光盘或官方网站 （通过挂载的方式访问）2.RPM查询官网网站3.Nginx软件官方网站4.MySQL软件官方网站</code></pre><p>rpm 安装的命令</p><pre class=" language-language-bash"><code class="language-language-bash">rpm [选项] rpm包名rpm包名-本地包名 在系统的某个目录下-远程包名 不用下载，直接使用网站上的rpm包# 选项-i 安装-v 显示过程-h 显示安装的进度条--test 仅测试，不安装--force 强制安装--nodeps 忽略依赖关系# 常用组合rpm -ivh rpm包名# 忽略依赖强制安装rpm -ivh --nodeps --force gcc-4.8.5-36.el7.x86_64.rpm# iv[root@localhost /mnt/Packages]# rpm -iv tree-1.6.0-10.el7.x86_64.rpmPreparing packages...   # 过程tree-1.6.0-10.el7.x86_64# ivh[root@localhost /mnt/Packages]# rpm -ivh tree-1.6.0-10.el7.x86_64.rpmPreparing...################################# [100%]Updating / installing...1:tree-1.6.0-10.el7################################# [100%]# --testrpm -ivh --test wget-1.14-18.el7.x86_64.rpm[root@localhost /mnt/Packages]# rpm -i gcc-4.8.5-36.el7.x86_64.rpmerror: Failed dependencies:cpp = 4.8.5-36.el7 is needed by gcc-4.8.5-36.el7.x86_64glibc-devel >= 2.2.90-12 is needed bygcc-4.8.5-36.el7.x86_64libmpc.so.3()(64bit) is needed by gcc-4.8.5-36.el7.x86_64libmpfr.so.4()(64bit) is needed by gcc-4.8.5-36.el7.x86_64rpm命令-查询# 网上下载rpm -ivh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-agent-5.0.1-1.el7.x86_64.rpm</code></pre><p>查询</p><pre class=" language-language-bash"><code class="language-language-bash"># 语法rpm 选项 rpm包名# 选项-q 查看指定的安装包是否安装(能单独使用)------------以下都需要配合-q使用---------------a 全部安装过的包-i 详细信息-l 列出rpm包相关的配置文件和目录-c 只查看该软件的包相关的配置文件-d 只查看改软件的帮助文档文件-f 反向查找，根据配置文件，反向查找包------------以上都需要配合上面选项使用-----------------p 查询未安装的包的相关信息# -qi[root@localhost ~]# rpm -qi grub2-pc-2.02-0.76.el7.centos.x86_64Name : grub2-pcEpoch : 1Version : 2.02Release : 0.76.el7.centosArchitecture: x86_64Install Date: Wed 08 Mar 2023 07:07:28 PMCSTGroup : System Environment/BaseSize : 0License : GPLv3+Signature : RSA/SHA256, Mon 12 Nov 201810:28:10 PM CST, Key ID 24c6a8a7f4a80eb5Source RPM : grub2-2.02-0.76.el7.centos.src.rpmBuild Date : Fri 09 Nov 2018 08:58:43 AMCSTBuild Host : kbuilder.bsys.centos.orgRelocations : (not relocatable)Packager : CentOS BuildSystem<http://bugs.centos.org>Vendor : CentOSURL :http://www.gnu.org/software/grub/Summary : Bootloader with support forLinux, Multiboot, and moreDescription :The GRand Unified Bootloader (GRUB) is ahighly configurable andcustomizable bootloader with modulararchitecture. It supports a richvariety of kernel formats, file systems,computer architectures andhardware devices.rpm -qc grub2-pc-2.02-0.76.el7.centos.x86_64rpm -ql grub2-pc-2.02-0.76.el7.centos.x86_64rpm -qd grub2-pc-2.02-0.76.el7.centos.x86_64rpm -qf /etc/grub2.cfg-qip 查询没有安装过包的详细信息-qlp 查询没有安装的包会产生那些文件-qcp 查询没有安装的包会产生那些配置文件-qdp 查询没有安装的包会产生那些帮助文件</code></pre><p>rpm 包升级</p><pre class=" language-language-bash"><code class="language-language-bash"># 选项-U updata升级，如果老版本不存在，则会安装新版本，如果老版本存在吗，会直接升级-f 老版本必须存在</code></pre><p>rpm 包卸载</p><pre class=" language-language-bash"><code class="language-language-bash"># 选项-e 后面接卸载包名</code></pre><p>光盘获取（挂载 / 卸载）</p><p>挂载</p><pre class=" language-language-bash"><code class="language-language-bash">挂载：mount  iso路径  需挂载的目录mount /dev/cdrom /mnt# 查看挂载信息df -h/dev/sr0 4.3G 4.3G 0 100% /mnt</code></pre><p>卸载</p><pre class=" language-language-bash"><code class="language-language-bash"># 卸载语法umount 目标路径umount /mnt/# 卸载挂载的报错umount /mnt/umount: /mnt: target is busy.(In some cases useful info aboutprocesses that usethe device is found by lsof(8) orfuser(1))## 原因，现在身处目标路径 ，会导致卸载不掉，目标正忙，离开目录即可</code></pre><p>yum 的使用</p><p>换源</p><pre class=" language-language-bash"><code class="language-language-bash">本地储存位置:/etc/yum.repos.d# 删除本地yum源rm -fr /etc/yum.repos.d/*# 更换base源wget -O /etc/yum.repos.d/CentOSBase.repohttp://mirrors.aliyun.com/repo/Centos-7.repo#或者curl -o /etc/yum.repos.d/CentOSBase.repohttp://mirrors.aliyun.com/repo/Centos-7.repo# 更换epel源wget -O /etc/yum.repos.d/epel.repohttp://mirrors.aliyun.com/repo/epel-7.repo# yum包缓存设置vim /etc/yum.conf[main]keepcache=0-------->1  #   0：关闭  1：开启# 加载yum缓存yum makecache# 查看本地缓存包/var/cache/yum/x86_64/7/updates/pckages</code></pre><p>yum 包查找</p><pre class=" language-language-bash"><code class="language-language-bash"># 查看yum仓库中所有可以安装的包yum list# 过滤[root@localhost ~]# yum list | grep vim# 包名  版本号 发布次数 系统平台 隶属那个源vim-common.x86_642:7.4.629-8.el7_9 @updates# 查看仓库中所有包的详细信息yum info</code></pre><p>yum 安装 / 更新</p><pre class=" language-language-bash"><code class="language-language-bash"># yum安装方法：一丶本地安装yum localinstall -y 包名    #包名得跟全路径二丶yum源安装yum install -y 包名三丶wget安装wget +URL四丶网站上安装yum install -y 包链接网站# -y：免交互方式#卸载：yum remove -y  包名yum erase -y   包名# 检查所有可以更新的包yum check-update# 更新yum update -y 包名  # 切记，要跟包名。否则此命令相当于升级linux所有可升级的包，包括内核</code></pre><p>什么是进程？</p><pre><code>在windows上安装的QQ，我们会将其称为QQ程序，那么当QQ运行之后，在任务管理器中，我们可以看到QQ程序在运行着，此时，我们称其为:QQ进程。</code></pre><p>进程的概念又是什么？</p><pre class=" language-language-bash"><code class="language-language-bash"># 进程是已启动的可执行程序的运行实例，进程有以下组成部分: 分配内存, 已分配内存的地址空间安全属性, 进程的运行身份和权限 进程代码, 运行一个或多个的线程 进程状态, 进程运行后的多种状态 静态程序, 二进制文件, 静态/bin/ls, /usr/sbin/sshd 动态进程, 程序运行的过程, 有生命周期及运行状态# 进程的运行环境，包括以下几个部分：局部和全局变量 当前的调度上下文 分配给进程使用的系统资源，例如文件描述符、网络端口等 给进程分配对应的pid,ppid</code></pre><p>进程和程序的区别又是什么？</p><pre class=" language-language-bash"><code class="language-language-bash">1.当程序运行为进程后，系统会为该进程分配内存，以及运行的身份和权限。 2.在进程运行的过程中，服务器上回有各种状态来表示当前进程的指标信息。</code></pre><p>进程的查看：ps</p><pre class=" language-language-bash"><code class="language-language-bash">语法：ps 选项 参数   #常用的语法有 ps -ef  ps  -aux选项：-a 显示所有与终端相关的进程，由终端发起的-u 显示所有进程的管理用户-x 显示与终端无关的-o 自定义展示-l 显示该进程的启动命令</code></pre><p>ps -aux 显示信息详解</p><pre class=" language-language-bash"><code class="language-language-bash">[root@hadoop101 ~]#ps -auxUSER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDUSER   #该进程的管理用户PID    #进程号%CPU   #该进程占用CPU的百分比%MEM   #该进程占用内存的百分比VSZ    #该进程占用虚拟内存的代销RSS    #该进程占用物理内存的大小TTY？    #由内核发起的进程tty   #机器上的终端进程pts/N  #远程链接工具的终端进程STAT   #程序的状态D  #无法中断的休眠进程（通IO进程）  //常用R  #正在运行的状态    //常用S  #处在休眠状态的进程    //常用T  #暂停或者被跟踪的状态   //常用W  #进入就交换内存的进程 （centos7见不到）X  #死掉的进程（少见）Z  #僵尸进程      //常用<  #优先级高的进程N  #优先级低的进程L  #有些数据页被锁进内存的进程s  #父进程，在底下有子进程l  #以线程的方式运行|  #存在多线程的进程+  #在前台运行    //常用START  #进程开启的时间TIME   #该进程占用cpu的时间COMMAND[]  #内核态 //由系统发起的进程没有[]  # 用户态进程  //由用户发起的进程</code></pre><p>后台进程</p><p>后台被暂停的进程</p><pre class=" language-language-bash"><code class="language-language-bash"># 查看所有暂停的进程   jobs[root@hadoop101 ~]#ping baidu.comPING baidu.com (110.242.68.66) 56(84) bytes of data.64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=1 ttl=128 time=33.8 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=2 ttl=128 time=38.9 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=3 ttl=128 time=32.9 ms^Z[1]+  Stopped                 ping baidu.com[root@hadoop101 ~]#vim jj[2]+  Stopped                 vim jj[root@hadoop101 ~]#jobs[1]-  Stopped                 ping baidu.com[2]+  Stopped                 vim jj# 命令#bg:让暂停的进程运行起来，后面加数字 bg是默认恢复最后一个[root@hadoop101 ~]#bg 1[1]- ping baidu.com &[root@hadoop101 ~]#64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=4 ttl=128 time=34.3 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=5 ttl=128 time=36.8 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=6 ttl=128 time=35.7 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=7 ttl=128 time=33.7 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=8 ttl=128 time=33.8 ms#fg:是吧后台暂停的进程，放置前台运行，后面加数字</code></pre><p>进程管理 TOP</p><p>top 信息解析</p><pre class=" language-language-bash"><code class="language-language-bash">[root@hadoop101 ~]#top#第一行top - 15:12:56 up  2:06,  2 users,  load average: 0.00, 0.01, 0.05top 命令15：12：56 当前的系统时间up 2：06 该服务的运行时间2 users 当前登录的用户数量load average: 0.00, 0.01, 0.05 系统的平均负载0.00 1分钟前0.01 5分钟0.05 15分钟前#第二行Tasks:  99 total,   2 running,  95 sleeping,   2 stopped,   0 zombie99 total 当前系统中所有的进程数量2 running 当前系统中所有的运行状态的进程数量95 sleeping 当前系统中所有的睡眠状态的进程数量2 stopped 当前系统中所有的暂停状态的进程数量0 zombie 当前系统中所有的僵尸状态的进程数量#第三行  cpu百分比%Cpu(s):  0.3 us,  0.0 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 stus 用户进程占用的cpu百分比sy 系统进程占用的cpu百分比ni 优先级较高的进程占用cpu的百分比id cpu的空闲容量wa 等待状态的进程占用cpu百分比hi 硬件终端占用cpu的百分比si 软件终端占用cpu的百分比st 虚拟化技术占用cpu的百分比#第四行  物理内存KiB Mem :  4323088 total,  3153580 free,   310264 used,   859244 buff/cache4323088 total 总内存数3153580 free 空闲内存310264 used 已使用内存859244 buff/cache buffer缓冲区/缓冲区#第五行  虚拟内存KiB Swap:  2093052 total,  2093052 free,        0 used.  3773604 avail Mem2093052 total 总虚拟内存2093052 free 空闲虚拟内存0 used 已使用的虚拟内存3773604 avail Mem 可用的虚拟内存书</code></pre><p>什么是中断？</p><pre><code>中断是系统用来影响硬件设备请求的一种机制。他会打断进程的正常调度和执行，然后调用内核中的终端处理程序来影响设备的请求</code></pre><p>top 命令的使用</p><pre class=" language-language-bash"><code class="language-language-bash">语法：top 选项选项：-d 指定刷新时间（默认是3秒）-p 只查看指定pid的进程-u 指定相关用户-b 将top中的内容保存至文件中-n 指定次数#top常见指令h 查看帮助z 高亮显示l  查看所有cpu的负载   //数字1s 设置刷新时间b 高亮显示处在R装态的进程M 按内存百分比进行排序输出P 按照cpu的百分比进行排序输出R 对排序进行反转f 自定义显示字段k kill掉指定的进程w 保存top的环境变量q 退出</code></pre><pre class=" language-language-bash"><code class="language-language-bash"> #top 选项参数说明 PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND  PID：进程的id号 USER：该进程的用户 PR NI ：该进程的优先级   #//-20最优先级，19最慢 VIRT ：虚拟内存占用空间 RES：物理内存占用空间 SHR：共享内存占用空间 S：进程的状态 %CPU：占用cpu的百分比 %MEM：占用内存的百分比 TIME+：运行时间COMMAND ：进程的运行命令</code></pre><p>什么是平均负载</p><pre class=" language-language-bash"><code class="language-language-bash">平均负载是指，单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，#因此，可以简单理解为,平均负载其实就是单位时间内的活跃进程数。</code></pre><p>平均负载多少时合理</p><pre class=" language-language-bash"><code class="language-language-bash">#首先最理想的状态是每个cpu上都刚好运行着-个进程，这样每个cpu都得到了充分利用所以在评判负载时，首先你要知道系统有几个CPU，这可以通过命令犹取，或grep mouername/proc/cpuinfo你要知道系统有几个cpu，这可以通过命令犹取，或grep鼠标名/proc/cpuinfo例1:架设现在在4，2, 1核的CPU上，如果平均负载为2时，意味着什么呢?1在4个CPU的系统上，意味着CPU有50%空闲。2.在2个CPU的系统上,以为这所有的CPU都刚好完全被占用。3.在1个CPU的系统上,则意味着有一半的进程竞争不到CPU。</code></pre><p>负载过高怎么解决</p><pre class=" language-language-bash"><code class="language-language-bash">下面我们以三个示例分别来看这三中情况，并用: stress、 mpstat、 pidstat等 工具找出平均负载升高的根源stresE是Linux系统压力测试工具,这里我们用作异常进程模拟平均负载升高的场景。mpstat是多核CPU性能分析工具,用来实时检查每个CPU的性能指标，以及所有CPU的平均指标。pidstat是一个常用的进程性能分析工具，用来实时查看进程的CPU,内存, I0,以及上下文切换等性能指标。#首先使用mpstat和pidstat来分析是什么原因造成的负载#找到原因后选择对应得解决方式，如果是某个命令造成得中断命令即可#又或者是其他部门在使用得时候造成，比如开发在导出日志数据等</code></pre><p>进程信号的管理</p><p><img src="https://s2.loli.net/2023/07/07/rUg1bojFwtPBsCe.png" alt=""></p><p>常用的信号：</p><table><thead><tr><th>数字信号</th><th>信号别名</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>HUP</td><td>挂起信号，往往可以让进程重新配置</td></tr><tr><td>2</td><td>INT</td><td>中断信号 类似 ctrl+c</td></tr><tr><td>3</td><td>QUIT</td><td>让进程退出 结果是让进程退出</td></tr><tr><td>9</td><td>KILL</td><td>直接结束进程，不能被进程捕获</td></tr><tr><td>15</td><td>TERM</td><td>进程终止。这是默认信号</td></tr><tr><td>18</td><td>CONT</td><td>被暂停的进程将恢复运行 放在后台运行 bg</td></tr><tr><td>19</td><td>STOP</td><td>暂停进程</td></tr><tr><td>20</td><td>TSTP</td><td>用户停止请求，类似 ctrl+z 把程序放置后台运行</td></tr></tbody></table><p>centos6 开机启动流程：</p><p>启动流程</p><pre class=" language-language-bash"><code class="language-language-bash">1丶内核引导2丶运行init3丶系统初始化4丶建立终端5丶用户登录系统--------------------------------------------------------------------------------一丶内核引导：BIOS通电自检，检测主板上的硬件设备读取/boot分区下所有的内核文件 二丶运行init：0  关机1  单用户级别2  多用户级别（没有文件系统）3  多用户级别(有文件系统)   #//  常用4  保留/没用5  多用户模式，进入GUI图形化操作  # //常用6  重启              #运行init会默认读取 /etc/inittab配置文件中的默认运行级别#centos6默认运行级别：id3:initdefault：#centos7默认运行级别multi-user.target：三：系统初始化根据运行设备设置开机自启动服务来启动#centos6：chkconfig --list#centos7：ll /etc/systemd/system/multi-user.target.wants/四丶建立终端五丶用户登录系统</code></pre><p>运行级别：</p><pre class=" language-language-bash"><code class="language-language-bash">1丶#运行级别（runlevel）的分类：运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，不能远程连接登录运行级别2：多用户状态 ，但是没有文件系统运行级别3：完全的多用户状态（有文件系统），登录后进入控制台终端命令行模式运行级别4：系统未使用，保留运行级别5：登录后进入图像化GUI模式运行级别6：系统正常关闭重启，默认运行级别不能设为6，否则不能正常启动</code></pre><p>查看运行级别：</p><pre class=" language-language-bash"><code class="language-language-bash">命令：runlevel[root@hadoop101 ~]#runlevelN 3</code></pre><p>Linux 关机命令：</p><pre class=" language-language-bash"><code class="language-language-bash">#关机init0shutdownpoweroffshutdown关机命令，可以使用--help使用查看shutdown –h 10#这个命令告诉计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。shutdown –h now 立马关机shutdown –h 20:25 系统会在今天20:25关机 #//却决于系统自带时间# 重启rebootinit6hutdown –r now 系统立马重启shutdown –r +10 系统十分钟后重启reboot 就是重启，等同于 shutdown –r now</code></pre><p>centos7 开机启动流程：</p><pre class=" language-language-bash"><code class="language-language-bash">1.BIOS(开机自检)2.MBR ( Master Boot Record 主引导记录)3.GRUB2 Bootloader（引导菜单）4.Kernel（内核引导）5.Systemd （不再使用init，改成了systemd）6.Runlevel-Target （运行级别）1丶BIOS自检：开机时，计算机会进行自检，即Basic Input/Output System (BIOS)自检，检测计算机的硬件设备是否正常工作。2丶启动引导程序加载：BIOS自检完成后，会将启动引导程序（boot loader）从硬盘加载到内存中，然后运行该程序。在CentOS 7中，启动引导程序为GRUB2。3丶内核加载：启动引导程序会加载Linux内核，即vmlinuz文件。内核是操作系统的核心之一，它会初始化计算机硬件设备，建立内存空间，加载驱动程序等操作。4丶初始RAM文件系统加载：内核加载后，它会加载一个叫做initramfs的文件系统。initramfs是一个临时的根文件系统，它包含了一些必要的驱动程序和工具，以便内核可以继续加载后续的文件系统。5丶根文件系统加载：在initramfs加载完成后，操作系统会加载真正的根文件系统，即根目录（/）所在的文件系统。在CentOS 7中，根文件系统可以是ext4、XFS、Btrfs等文件系统。6丶systemd初始化：CentOS 7使用systemd作为启动管理器，systemd会在内核加载完成后启动。它会读取系统配置文件，初始化系统服务，并启动用户空间进程。7丶用户空间进程启动：在systemd初始化完成后，操作系统会启动用户空间进程，包括登录管理器（如GDM、LightDM等）和用户桌面环境（如GNOME、KDE等）。用户可以通过登录管理器登录系统，然后进入桌面环境开始使用计算机。</code></pre><p>运行级别：</p><pre class=" language-language-bash"><code class="language-language-bash">0 – 关闭系统   #//runlevel0.target -> poweroff.target1 – 单用户模式  #//runlevel1.target -> rescue.target2 – 多用户模式，无网络连接   #//runlevel2.target -> multi-user.target3 – 多用户模式，有网络连接，命令行界面  #//runlevel3.target -> multi-user.target4 – 未使用   #//runlevel4.target -> multi-user.target5 – 图形化界面  #//runlevel5.target -> graphical.target6 – 重启系统  #//runlevel6.target -> reboot.target#默认运行级别为3。可以使用以下命令查看当前运行级别：systemctl get-default#可以使用以下命令修改默认运行级别：其中，<target>可以是上述7个运行级别中的任意一个。例如，设置默认运行级别为图形化界面（运行级别5）：systemctl set-default <target>例：systemctl set-default graphical.target#注意，在CentOS 7中，运行级别的概念已经被替代为"targets"。因此，可以使用以下命令列出所有可用的"targets"：systemctl list-units --type=target</code></pre><p>systemctl 系统服务</p><p>启动服务</p><p>centos7</p><pre class=" language-language-bash"><code class="language-language-bash">#在centos7中我们使用的系统服务命令是systemctl，语法：systemctl [动作] 服务名常用动作：start  //开启restart  //重启stop   //停止status  //查看服务状态reload   //出重新加载is-active  //判断服务是否在运行mask   //禁用unmask  //取消禁用</code></pre><p>centos6</p><pre class=" language-language-bash"><code class="language-language-bash">语法：/etc/init.d/服务名 start#其他语法动作同上，只是后面动作不一样而已</code></pre><p>开机自启服务管理</p><pre class=" language-language-bash"><code class="language-language-bash"># 查看开机自启的服务有哪些chkconfig#设置开机自启systemctl enable [服务名]#关闭自启服务systemctl disable [服务名]# 查看指定服务是否开机自启语法：systemctl is-enabled [服务名][root@hadoop103 ~]# systemctl is-enabled networkenabled  //允许开机自启[root@hadoop103 ~]# systemctl is-enabled firewallddisabled  //不允许开机自启</code></pre><p>crontab 配置文件详解</p><pre class=" language-language-bash"><code class="language-language-bash">[root@hadoop103 ~]# vim /etc/crontab SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)  //表示分钟 0-59# |  .------------- hour (0 - 23)  //表示小时 0-23 # |  |  .---------- day of month (1 - 31)  //表示天  1-31# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...  //表示月 1-12 # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR   //表示周 1-7 sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name  command to be executed</code></pre><p><strong>crontab 字段的意义</strong>：</p><p><img src="https://s2.loli.net/2023/07/07/ePkamLG5JgZdsfR.png" alt=""></p><p><strong>crontab 辅助字符</strong></p><p><img src="https://s2.loli.net/2023/07/07/lu3aQeqpwoDGb8I.png" alt=""></p><p>使用方法</p><pre class=" language-language-bash"><code class="language-language-bash">语法：crontab [选项] 选项：-l ：列出当前用的所有定时任务-e ：编写新的定时任务-u ：指定定时任务的用户-r ：删除定时任务，（一般用于删除所有指定任务）</code></pre><p>系统的 crontab 配置文件</p><pre class=" language-language-bash"><code class="language-language-bash">/etc/cron.allow 将可以使用的crontab账号写入其中，不在这个文件的使用者则不可使用crontab/etc/cron.deny 将不可以使用crontab账号写入其中，若未记录到这个当中的使用者，就可以使用crontab。1. /etc/crontab.allow 比 /etc/cron.deny优先，建议只保留一个即可，一般系统默认是保留/etc/cron.deny,可以将不想让他执行crontab那个执行者写入/etc/cron.deny当中，一个账号一行。2.当用户使用crontab这个指令建立定时任务后，就会被记录到/var/spool/cron里面，而且是以账号来作为判断。3.另外，cron执行的每一项工作都会记录到/var/log/cron 日志中</code></pre><p>例题：</p><pre class=" language-language-bash"><code class="language-language-bash"># 每天凌晨两点 执行ls00 02 * * * ls >/dev/null# 每个月的1号的凌晨两点执行ls00 02 1 * * ls# 每年的2.14号的凌晨执行ls00 02 14 2 * ls# 每周日 凌晨2点执行ls00 02 * * 7 ls# 每天凌晨2点没10分钟执行ls*/10 02 * * * ls# 没月的1~8号凌晨两点执行00 02 1-8 * * ls# 每个月的每隔2天的8点到11点的03分和15分分别执行ls命令3,15 8-11 */2 * *</code></pre><p>时间同步</p><p>安装 ntpdate</p><pre class=" language-language-bash"><code class="language-language-bash">yum install -y ntpdate</code></pre><p>时间同步</p><pre class=" language-language-bash"><code class="language-language-bash">ntpdate time1.aliyun.com  //time后面是数字1</code></pre><p>编写时间同步定时</p><pre class=" language-language-bash"><code class="language-language-bash">[root@hadoop101 ~]#crontab -e# userage:sync DATE   Date:2023/4/5 by:jiujiu* * * * * /usr/sbin/ntpdate time1.aliyun.con &>/dev/null</code></pre><p>查看定时任务日志：</p><pre class=" language-language-bash"><code class="language-language-bash">tail -f /var/log/cron</code></pre><p>编写思路</p><pre class=" language-language-bash"><code class="language-language-bash">1.手动执行命令，然后保留执行成功的结果。2.编写脚本脚本需要统一路径/scripts脚本内容复制执行成功的命令(减少每个环节出错几率)脚本内容尽可能的优化, 使用一些变量或使用简单的判断语句脚本执行的输出信息可以重定向至其他位置保留或写入/dev/null3.执行脚本使用bash命令执行, 防止脚本没有增加执行权限(/usr/bin/bash)执行脚本成功后，复制该执行的命令，以便写入cron4.编写计划任务加上必要的注释信息, 人、时间、任务设定计划任务执行的周期粘贴执行脚本的命令(不要手敲)5.调试计划任务增加任务频率测试检查环境变量问题检查crond服务日志##创建当前时间当前日期的目录mkdir $(date +%F-%r)</code></pre><p>拒绝某个用户使用定时任务：</p><pre class=" language-language-bash"><code class="language-language-bash">vim /etc/cron.denyjiujiu# 想拒绝谁就把谁写进/etc/cron.deny</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;markdaown 语法&lt;/p&gt;
&lt;pre class=&quot; language-language-bash&quot;&gt;&lt;code class=&quot;language-language-bash&quot;&gt;基础语法
标题：一级标题[# 正文]二级标题[## 正文]
目录：[TO</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三剑客</title>
    <link href="https://jiujiu.tj.cn/[object%20Object]/%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>https://jiujiu.tj.cn/[object%20Object]/%E4%B8%89%E5%89%91%E5%AE%A2/</id>
    <published>2023-07-07T00:21:35.000Z</published>
    <updated>2023-07-22T03:57:15.766Z</updated>
    
    <content type="html"><![CDATA[<p>三剑客 grep 丶 awk 丶 sed</p><p>正则表达式</p><p>1.1 什么是正则表达式</p><ul><li>匹配一些<font color = 'red'>有规律的</font>东西，比如手机号丶日志文件等</li><li>正则表达式 regular expression (RE)</li><li>正则使用：使用一些符号表达重复出现大小写，开头 / 结尾含义</li></ul><p>1.2 应用场景</p><table><thead><tr><th>正则表达式</th><th>Linux 三剑客使用，或者一些开发语言 (python,golang…)</th></tr></thead><tbody><tr><td>应用场景</td><td>过滤有规律的内容，尤其是日志</td></tr></tbody></table><p>1.3 正则使用事项</p><ul><li>所有的符号英文符号</li><li>学习正则，是通过 grep 命令学习 grep 加上单引号 如  grep ‘xxx’</li><li>注意系统的字符集；en_US.UTF-8 , 如果字符集出现问题修改成 C ( <code>export LANG=c</code> )</li><li>快速掌握正则：配合 grep -o 参数学习</li></ul><p>1.4 正则符号</p><table><thead><tr><th>分类</th><th></th><th>命令</th></tr></thead><tbody><tr><td>基础正则</td><td>^  $  ^$   .   *    .*  \</td><td>grep/sed/awk</td></tr><tr><td>扩展正则</td><td>+ | () {} ?</td><td>egrep/sed-r/awk</td></tr></tbody></table><p>1.5 正则 vs 通配符</p><table><thead><tr><th>分类</th><th>用途</th><th>支持的命令</th></tr></thead><tbody><tr><td>正则 (RE)</td><td>三剑客，高级语言，进行过滤</td><td>三剑客 grep 丶 awk 丶 sed 丶 find</td></tr><tr><td>通配符 (pathname extenslon  或 glob)</td><td 1..10="">匹配文件 (文件名)*.txt  *.log</td><td>Linux 下面的大部分命令</td></tr></tbody></table><p>1.6 基础正则</p><p>1)<strong>^</strong></p><pre class=" language-language-bash"><code class="language-language-bash">作用：表示以什么开始...的行例：搜素文件txt中以a开头的行grep '^a'  [文件名(txt)]注：如果没有任何提示，则表示要么字符有问题或者没有已a开头的行</code></pre><p>2)$</p><pre class=" language-language-bash"><code class="language-language-bash">作用：表示已什么..结尾例：搜素文件txt中以a结尾的行grep 'a$'  [文件名(txt)]注：搜素结尾$得在后面</code></pre><p>3)^$</p><pre class=" language-language-bash"><code class="language-language-bash">作用：表示搜素空行空行这一行中没有任何内容(空格也是符号)例：搜素文件txt中的空行grep '^$'  [文件名(txt)]-v:反向抓取，也可用于排除(我想搜索123，加-v的话就是除了123显示 其他都显示)</code></pre><p>4）.</p><pre class=" language-language-bash"><code class="language-language-bash">表示任意一个字符(.不匹配空行)</code></pre><p>5）\ 转义字符</p><pre class=" language-language-bash"><code class="language-language-bash">作用：表示去除原本特殊含义例;搜素文件txt.(点)结尾的行[root@hadoop100 ~]# grep '.$' txt ifgdsfgdsdfsss.trete.ggdfgderyerstr.srtgrttrtgdfsfds.d注;如果以.$正则来搜索的话，结果是任意一个字符结尾的行[root@hadoop100 ~]# grep '\.$' txt sdfsss.str.加上\转义符后，就去除了.(点)原本的匹配任意字符的含义</code></pre><ul><li><p>转义字符序列 (部分)</p><ul><li>\n  表示回车换行</li><li>\t  表示 tab 键</li></ul></li></ul><p>6）*</p><pre class=" language-language-sh"><code class="language-language-sh">作用：*(星号)前一个字符匹配连续出现0次或者次以上例：[root@hadoop100 ~]# grep 's*' txt ifgdsfgdsdfsss.trete.ggdfgderyerstr.srtgrttrtgdfsfds.d注：刚开始*比较少单独用，熟练掌握正则后</code></pre><p>7）.</p><pre class=" language-language-bash"><code class="language-language-bash">作用：在正则表达式里面表示所有内容， 任何内容，任意内容整体记忆：.*表示所有即可拆分： .（点）任意一个字符+ *前一个字符出现0次或者0次以上，加起来就表示所有了</code></pre><ul><li>扩展<ul><li>匹配以 s 开头到的任意结尾行<ul><li>[root@hadoop100 ~]# grep ‘^s.*’ txt<br>sdfsss.<br>str.<br>srtgrt<br>sdadwaet</li></ul></li><li>匹配以 s 开头 t 结尾的行，中间任意内容<ul><li>[root@hadoop100 ~]# grep ‘^s.*t’ txt<br>str.<br>srtgrt<br>sdadwaet</li></ul></li><li>正则特色<ul><li>正则表达式得到贪婪行，.* 表示所有或 * 连续出现的时候，会尽可能的过度匹配</li></ul></li></ul></li></ul><ol start="8"><li>[] 中括号</li></ol><pre class=" language-language-bash"><code class="language-language-bash">[abc] 1次匹配1个字符，匹配任何一个字符[a或b或c][]里面的内容去掉特殊意义，比如.在括号里面就是普通点例;[root@hadoop100 ~]# cat txt ifgdsfgdsdfsss.trete.ggdfgderyerstr.srtgrttrtgdfsfds.dsdadwaet[root@hadoop100 ~]# grep '[abc]' txt sdadwaet注：通常如果匹配多个字符的情况下可以用什么到什么来写如：匹配a到z的行[root@hadoop100 ~]# grep '[a-z]' txt ifgdsfgdsdfsss.trete.ggdfgderyerstr.srtgrttrtgdfsfds.dsdadwaet如何匹配多个不同字符例;匹配txt文件中的大写和数字[root@hadoop100 ~]# grep '[A-Z0-9]' txt AdwsXfsF oDSADSA543DASA注：大小写可以简写成a-Z</code></pre><p>9）[^]</p><pre class=" language-language-bash"><code class="language-language-bash">作用：取反丶排除例：grep '[^abc]' txt表示：从txt中标记所有的包含abc的词，输出剩下行</code></pre><p>10）总结</p><table><thead><tr><th>基础正则</th><th>含义</th><th>搭配</th></tr></thead><tbody><tr><td>^</td><td>以… 开头的行</td><td></td></tr><tr><td>$</td><td>以… 结尾的行</td><td></td></tr><tr><td>^$</td><td>表示空行</td><td>搭配固定</td></tr><tr><td>.</td><td>任意一个字符</td><td></td></tr><tr><td>*</td><td>前一个字符连续出现 0 次或者 0 次以上</td><td></td></tr><tr><td>.*</td><td>表示所有内容</td><td>搭配</td></tr><tr><td>\</td><td>转义符字符，、\n  \t</td><td></td></tr><tr><td>正则贪婪性</td><td>.* 的时候或者是连续出现</td><td>一般与 + 号搭配</td></tr><tr><td>[]</td><td>一个整体，匹配里面任意一个字符</td><td></td></tr><tr><td>[^]</td><td>取反，排除，也是一个整体</td><td></td></tr></tbody></table><p>1.7 扩展正则</p><table><thead><tr><th>符号</th><th></th><th></th></tr></thead><tbody><tr><td>+</td><td></td><td></td></tr><tr><td>|</td><td></td><td></td></tr><tr><td>（）</td><td></td><td></td></tr><tr><td>{}</td><td></td><td></td></tr><tr><td>？</td><td></td><td></td></tr></tbody></table><p>1）+  前一个字符出现 1 次或者 1 次以上</p><pre class=" language-language-bash"><code class="language-language-bash">注：grep不支持扩展正则，得用egrep[root@hadoop102 ~]# grep '6+' txt [root@hadoop102 ~]# egrep '6+' txt 43466666634235435643#或者在+前面加上转义字符\[root@hadoop102 ~]# grep '6\+' txt 43466666634235435643</code></pre><ul><li>匹配出连续出现的数字</li></ul><pre class=" language-language-bash"><code class="language-language-bash">[root@hadoop102 ~]# egrep '[0-9]+' txt 434666666342354356435e5ye5745y# -o；只输出匹配的内容[root@hadoop102 ~]# egrep -o '[0-9]+' txt 43466666634235435643555745</code></pre><p>2）|  或者</p><pre class=" language-language-bash"><code class="language-language-bash">#同中括号大同小异，中括号解决不了就可以用 | [root@hadoop102 ~]# cat txt sdfsdfssdfsdfsddddghggrrcxgrsg434666666dtsfgdrge34235435643 etrtgr5e5yye5745yrtd:wq[root@hadoop102 ~]# egrep 'e|4' txt 434666666dtsfgdrge34235435643etrtgr5e5ye5745y</code></pre><table><thead><tr><th>符号</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>[]</td><td>1 次匹配一个字符</td><td>匹配单个字符 [] 和 +</td></tr><tr><td>|</td><td>匹配 1 个字符或者多个字符</td><td>匹配单词的时候</td></tr></tbody></table><p>3） （） 被括起来的内容，表示一个整体   反向引用（一般用于 sed）</p><ul><li>被括起来的内容，表示一个整体</li><li>反向引用（一般用于 sed）</li></ul><ol start="4"><li>{}  连续出现 o {n，m}  前一个字母 o 最少连续出现 n 次，最多出现 m 次</li></ol><table><thead><tr><th>符号</th><th></th><th></th></tr></thead><tbody><tr><td n，m="">o</td><td>前一个字母 o 最少连续出现 n 次，最多出现 m 次</td><td></td></tr><tr><td n="">o</td><td>前一个字母 o 连续出现 n 次</td><td></td></tr></tbody></table><p><img src="https://s2.loli.net/2023/07/07/JWEUfjDHGdhlwNi.png" alt=""></p><p>5） ？ 前一个字符出现 0 次或者 1 次</p><p><img src="https://s2.loli.net/2023/07/07/WvfJxtU6C1ZK7Nd.png" alt=""></p><p>6） 扩展正则总结</p><table><thead><tr><th>符号</th><th>含义</th><th>搭配</th></tr></thead><tbody><tr><td>+</td><td>前一个字符出现 1 次或者 1 次以上</td><td>[]+</td></tr><tr><td>|</td><td>或者</td><td></td></tr><tr><td>[]</td><td>一个整体，sed 反向引用</td><td></td></tr><tr><td>{}</td><td>前一个字母 o 最少连续出现 n 次，最多出现 m 次</td><td></td></tr><tr><td>?</td><td>前一个字符出现 0 次或者 1 次</td><td></td></tr></tbody></table><p>2.1 三剑客</p><p>三剑客的特点及应用</p><table><thead><tr><th>命令</th><th>特点</th><th>应用</th></tr></thead><tbody><tr><td>grep</td><td>过滤丶查找</td><td>grep 过滤的速度是最快的</td></tr><tr><td>sed</td><td>替换，修改文件内容丶取 行</td><td>如果要替换 / 修改文件内容，取出某个范围的值</td></tr><tr><td>awk</td><td>取列，统计计算</td><td>取列丶对比比较丶统计计算</td></tr></tbody></table><p>grep</p><table><thead><tr><th>选项</th><th>含义</th><th></th></tr></thead><tbody><tr><td>-E</td><td>=egrep</td><td></td></tr><tr><td>-A</td><td>例：-A5 匹配你要的内容显示下接来的 5 行</td><td></td></tr><tr><td>-B</td><td>例：-B5 匹配你要的内容显示接上面的 5 行</td><td></td></tr><tr><td>-C</td><td>例：-C 5 匹配你要的内容显示上下面的 5 行</td><td></td></tr><tr><td>-c</td><td>统计出现了多少次行，同 wc -l</td><td></td></tr><tr><td>-v</td><td>取反丶排除 (行)</td><td></td></tr><tr><td>-n</td><td>显示行号</td><td></td></tr><tr><td>-i</td><td>忽略大小写</td><td></td></tr><tr><td>-w</td><td>匹配单词</td><td></td></tr></tbody></table><p>-o                        精确过滤</p><p><img src="https://s2.loli.net/2023/07/07/ZqPkL2SydC8xQjm.png" alt=""></p><p>sed</p><p>字符串替换</p><pre class=" language-language-bash"><code class="language-language-bash">语法：sed 's/原字符串/替换字符串/' [文件路径]#注意：#若存在特殊字符，需要使用反斜线\进行转义；#若存在单引号，外层的单引号改成双引号 sed "s/原字符串/替换字符串/"#删除某一个字符串可写为：sed 's/原字符串//g'替换所有匹配到的关键字：sed 's/原字符串/替换字符串/g'# 在末尾加g替换每一个匹配的关键字,否则只替换每行的第一个#替换文件整行内容：例：把unr第四行替换成www.baidu[root@hadoop102 ~]#sed -i '4c\www.baidu' unr   选项功能-e直接在命令行模式上进行sed动作编辑，此为默认选项-f将sed的动作写在一个文件内，用–f filename 执行filename内的sed动作-i直接修改文件内容-n只打印模式匹配的行-r支持扩展正则表达式-h --help显示帮助-v --version显示版本信息#命令：a\在当前行下面插入文本i\在当前行上面插入文本c\把选定的行改为新的文本d删除，删除选择的行D删除模板块的第一行s替换指定字符h拷贝模板块的内容到内存中的缓冲区H追加模板块的内容到内存中的缓冲区g获得内存缓冲区的内容，并替代当前模板块中的文本G获得内存缓冲区的内容，并追加到当前模板块文本的后面l列表不能打印字符的清单n读取下一个输入行，用下一个命令处理新的行而不是用第一个命令N追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码p打印模板块的行P打印模板块的第一行q退出Sedblable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾rfile 从file中读行tlabel if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾Tlabel 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾wfile 写并追加模板块到file末尾Wfile 写并追加模板块的第一行到file末尾!表示后面的命令对所有没有被选定的行发生作用=打印当前行号#把注释扩展到下一个换行符以前#sed 替换标记 (s 替换脚本命令)标记作用n1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这时就用到这个标记g行内全局替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 Ap会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用w将缓冲区中的内容写到指定的 file 文件中x互换模板块中的文本和缓冲区中的文本y把一个字符翻译为另外的字符（但是不用于正则表达式）\n匹配第n个子串，该子串之前在pattern中用 () 指定&已匹配字符串标记，用正则表达式匹配的内容进行替换\转义（转义替换部分包含：&、\ 等）</code></pre><ul><li>特点及格式<ul><li>sed stram edior 流编辑器，sed 把处理的内容 (文件) 当作是水，源源不断的进行处理，直到文件末尾</li><li>sed 格式</li></ul></li></ul><table><thead><tr><th>命令</th><th>选项</th><th>(s）sed 命令功能 (g) 修饰符</th></tr></thead><tbody><tr><td>sed</td><td>-r</td><td>‘s#oldboy#oldgirl#g’</td></tr></tbody></table><ul><li>sed 命令核心功能</li></ul><table><thead><tr><th>功能</th><th></th></tr></thead><tbody><tr><td>s</td><td>替换 (substitute)  sub</td></tr><tr><td>P</td><td>显示</td></tr><tr><td>d</td><td>delete</td></tr><tr><td>cai</td><td>增加</td></tr></tbody></table><p>3） sed 查找</p><p>选项：</p><p>-n：按行号查找，搭配<strong> p</strong> 使用  例：sed  -n ‘5p’  jiujiu.txt  注：如果不加 - n，则原文输出并重复输出指定行一遍 - e      多重编辑，且命令顺序会影响结果<br> - f       指定一个 sed 脚本文件到命令行执行，<br>-r       Sed 使用扩展正则<br> - i       直接修改文档读取的内容，不在屏幕上输出</p><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>p</td><td>行号的意思</td></tr><tr><td>d</td><td>删除（不加 - 选项 ）</td></tr></tbody><tbody><tr><td>查找格式</td><td></td></tr><tr><td>------------------</td><td>------------------------------------------------------------</td></tr><tr><td>‘2p’</td><td>指定行号查找</td></tr><tr><td>‘1,5p’</td><td>指定行号范围查找</td></tr><tr><td>‘/xxxx/p’</td><td>类似于‘grep’过滤，// 里面可以写正则  例：sed -n ‘/^s/p’  jiujiu.txt</td></tr><tr><td>‘/10:00/,/11:00/p’</td><td>表示范围的过滤，如果结尾范围输错，则从哪里开始查找输出到结尾</td></tr></tbody></table><p>4）删除 d</p><table><thead><tr><th>删除格式</th><th></th></tr></thead><tbody><tr><td>‘2d’</td><td>指定行号删除</td></tr><tr><td>‘1,5d’</td><td>指定行号范围删除</td></tr><tr><td>‘/xxxx/’</td><td>类似于‘grep’过滤，// 里面可以写正则  例：sed -n ‘/^s/d’  jiujiu.txt</td></tr><tr><td>‘/10:00/,/11:00/p’</td><td>表示范围的过滤，如果结尾范围输错，则从哪里开始删除输出到结尾</td></tr><tr><td>注：d 是删除一行</td><td>常用：例 sed ‘5d’ jiujiu.txt</td></tr></tbody></table><p>案例：删除文件中得到空行和包含 #的行</p><pre class=" language-language-bash"><code class="language-language-bash">egrep -v '^$|#' /etc/ssh/sshd_configsed -r '/^$|#/d' /etc/ssh/sshd_config# !的妙用在sed和awk中表示取反sed -nr '/^$|#/!p' /etc/ssh/sshd_config  #!p表示不显示空行/包含#号的行</code></pre><p>5）增加 ：cai</p><table><thead><tr><th>命令</th><th>含义</th><th></th></tr></thead><tbody><tr><td>c   （replace）替代</td><td>替换这行的内容</td><td></td></tr><tr><td>**a ** （append）追加    * 重点</td><td>向指定的行或每一行追加内容 （相当于 &gt;&gt;）【行的末尾追加】</td><td></td></tr><tr><td>i      (insert) 插入</td><td>向指定的行或每一行插入内容  （行的前面插入）</td><td></td></tr></tbody></table><p>例：</p><pre class=" language-language-bash"><code class="language-language-bash">#在txt中第四行下面追加一句jiujiu[root@hadoop100 ~]# sed '4a jiujiu' txt #在txt中第四行上面追加一句jiujiu[root@hadoop100 ~]# sed '4i jiujiu' txt#把txt中第四行删除并改为jiujiu[root@hadoop100 ~]# sed '4c jiujiu' txt</code></pre><p>试题：</p><p>向 config 文件中追加多行内容</p><pre class=" language-language-bash"><code class="language-language-bash">#需追加内容为：UseDNS noGSSAPIAUTCATTON nopermitRootLogin no #方法一 cat >> config << EOF UseDNS noGSSAPIAUTCATTON nopermitRootLogin noEOF#如果要追加的内容包含特殊符号，则在EOF两边加是‘’#方法二sed '$a UseDNS no\GSSAPIAUTCATTON no\permitRootLogin no'  config</code></pre><p>6) 替换：s</p><p>替换格式：</p><pre class=" language-language-bash"><code class="language-language-bash">语法：sed 's#xxx#xxx#g'  s:#想要的搜索内容#想替换的内容#g     s：搜索                     g：全局</code></pre><p>反向引用：</p><p>口诀：先保护，在使用</p><pre class=" language-language-bash"><code class="language-language-bash">例：把hello，world前后反过来[root@hadoop102 ~]# echo hello,world hello,world[root@hadoop102 ~]# echo hello,world | sed -r 's#(^.*),(.*$)#\2 \1#g'world hello注：尽量使用#</code></pre><p>awk</p><p>1）awk 基本概念</p><pre class=" language-language-bash"><code class="language-language-bash">  awk 是一个按需求格式化文本再进行输出的工具。  和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。  awk -f 脚本文件 数据文件  执行awk脚本文件  awk 的应用场景：看下 awk 能干些什么事情：1. 能够将给定的文本内容，按照我们期望的格式输出显示，打印成报表。2. 分析处理系统日志，快速地分析挖掘我们关心的数据，并生成统计信息；3. 方便地用来统计数据，比如网站的访问量，访问的 IP 量等；4. 通过各种工具的组合，快速地汇总分析系统的运行信息，让你对系统的运行了如指掌；5. 强大的脚本语言表达能力，支持循环、条件、数组等语法，助你分析更加复杂的数据；awk 不是万能的，它比较擅长处理格式化的文本，比如 日志、 csv 格式数据等；</code></pre><p>awk 的工作流程图如图</p><p><img src="https://s2.loli.net/2023/07/07/Rgnm7lUWc3V5GaX.png" alt=""></p><p>工作原理：</p><p>逐行读取文本，默认以空格或 tab 键为分隔符进行分隔，将分隔所得的各个字段保存到内建变量中，并按模式或者条件执行编辑命令。</p><p>在使用 awk 命令的过程中，可以使用逻辑操作符 “&amp;&amp;” 表示 “与”、“||” 表示 “或”、“!” 表示 “非”；还可以进行简单的数学运算，如 +、-、*、/、%、^ 分别表示加、减、乘、除、取余和乘方。</p><p>2）语法</p><pre class=" language-language-bash"><code class="language-language-bash">举例：# awk -F: 'BEGIN&#123;print"-----header-----"&#125; &#123;print $1,$7&#125; END&#123;print"-----footer-----"&#125;' /etc/passwd</code></pre><p>3）awk 结构</p><pre class=" language-language-bash"><code class="language-language-bash">1. BEGIN 区域Begin 区域的语法:BEGIN &#123; awk-commands &#125;BEGIN 区域的命令只最开始、在 awk 执行 body 区域命令之前执行一次。BEGIN 区域很适合用来打印报文头部信息，以及用来初始化变量。BEGIN 区域可以有一个或多个 awk 命令关键字 BEGIN 必须要用大写BEGIN 区域是可选的2. body 区域body 区域的语法:/pattern/ &#123;action&#125;body 区域的命令每次从输入文件读取一行就会执行一次如果输入文件有 10 行，那 body 区域的命令就会执行 10 次(每行执行一次)Body 区域没有用任何关键字表示，只有用正则模式和命令。Body 区域是可选的3. END 区域END 区域的语法:END &#123; awk-commands &#125;END 区域在 awk 执行完所有操作后执行，并且只执行一次。END 区域很适合打印报文结尾信息，以及做一些清理动作END 区域可以有一个或多个 awk 命令关键字 END 必须要用大写END 区域是可选的提示：如果命令很长，即可以放到单行执行，也可以用\折成多行执行。</code></pre><p>行与列</p><table><thead><tr><th>名词</th><th>awk 一些叫法</th><th>一些说明</th></tr></thead><tbody><tr><td>行</td><td>记录 (record)</td><td>每一行默认通过回车分割的</td></tr><tr><td>列</td><td>字段 (field)</td><td>每一列默认通过空格分割的</td></tr><tr><td>awk 中行与列结束的标记都是可以修改的</td><td></td><td></td></tr></tbody><tbody><tr><td>内置变量</td><td>功能</td></tr><tr><td>--------</td><td>------------------------------------------------------------</td></tr><tr><td>NF</td><td>当前处理的行的字段个数（就是：有多少列）</td></tr><tr><td>NR</td><td>当前处理的行的行号（就是：有多少行）例：NR==1 [取出某一行]</td></tr><tr><td>FNR</td><td>读取文件的记录数（行号），从 1 开始，新的文件重新从 1 开始计数</td></tr><tr><td>$0</td><td>当前处理的行的整行内容（就是：表示一行的内容）</td></tr><tr><td>$n</td><td>当前处理行的第 n 个字段（就是：第 n 列）</td></tr><tr><td>FILENAME</td><td>被处理的文件名</td></tr><tr><td>FS</td><td>指定每行的字段分隔符，默认为空格或制表位（相当于选项 -F ）</td></tr><tr><td>OFS</td><td>输出字段的分隔符，默认也是空格</td></tr><tr><td>RS</td><td>行分割符。awk 从文件上读取资料时，将根据 Rs 的定义把资料切割成许多条记录，而 awk 一次仅读取一条记录，预设值是 “\n“</td></tr><tr><td>ORS</td><td>输出分割符，默认也是换行符</td></tr></tbody></table><p>1）取行</p><table><thead><tr><th>awk</th><th></th></tr></thead><tbody><tr><td>NR==1</td><td>取出某一行</td></tr><tr><td>NR&gt;=1&amp;&amp;（并且）NR&lt;=5</td><td>取出 1 到 5 行范围</td></tr><tr><td>常用符号</td><td>&gt;  &lt;=&gt;=   &lt;=   ==  !=（不等于）</td></tr><tr><td>/jiujiu/</td><td>//(双斜线搜索 / 过滤)</td></tr><tr><td>/xx/，/xx/</td><td>例：[root@hadoop102 ~]# awk ‘/1/,/4/’ like<br/>1hello ,world<br/>2like<br/>4linux</td></tr></tbody></table><p>2）取列</p><p>在 awk 中取列首先要认识 - F</p><ul><li>-F：指定分隔符，指定每一列结束标记 (默认是空格 / 连续的空格 / 还有 tab 键)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>数字：表示取出某一列注意：在</mtext><mi>a</mi><mi>w</mi><mi>k</mi><mtext>中</mtext></mrow><annotation encoding="application/x-tex">数字：表示取出某一列 注意：在awk中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">某</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">中</span></span></span></span>内容一个意思，表示取出某一列</li><li>$0: 表示整行的内容</li><li print="" xxx="">取列一般是</li><li>$NF: 表示取最后一列</li></ul><p>小结</p><ul><li>行与列的认知，[行：记录   列：字段 / 域]</li><li>awk 取行与取列</li><li></li></ul><p>awk 模式匹配</p><table><thead><tr><th>awk</th><th>-F&quot;[ /]+&quot;</th><th>‘NR==2{print $2}’</th></tr></thead><tbody><tr><td>命令</td><td>选项</td><td>‘条件 {动作}’</td></tr></tbody></table><ul><li>比较符号：&lt;(小于)  &gt;(大于)  =（等于） &gt;=(大于等于)  &lt;=(小于等于)   !=(不等于)</li><li>正则：</li><li>范围： 表达式 ；</li><li>特殊条件：BEGIN 和 END</li></ul><p>1）比较表达式 - 参考上面取行部分</p><p>2）正则：</p><ul><li>//(双划线) 支持扩展正则</li><li>awk 可以精确到某一列，某一列中包含 / 不包含… 内容</li><li>~  ：包含</li><li>!~: 不包含</li></ul><table><thead><tr><th>正则</th><th>awk 正则</th></tr></thead><tbody><tr><td>^  表示… 开头</td><td>某一列的开头  $2~/^like/ : 第二列以 like 开头的</td></tr><tr><td>$  表示… 结尾</td><td>某一列的结尾   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mtext> </mtext><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>k</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">2~/like</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span></span></span></span>/ : 第二列以 like 结尾的</td></tr><tr><td>^$  空行</td><td>某一列的空的   2~/^/ : 第二列空行的</td></tr></tbody></table><pre class=" language-language-bash"><code class="language-language-bash">练习：#找出第三列以2开头的行，并显示第一列，第三列，最后一列文件：/etc/passwd[root@hadoop102 ~]# awk -F: '$3~/^2/' /etc/passwd| awk -F : '&#123;print $1,$3,$NF&#125;'#取找出第三列以1或者2开头的行，并显示第一列，第三列，最后一列 awk -F: '$3~/^[12]/' /etc/passwd| awk -F : '&#123;print $1,$3,$NF&#125;' awk -F: '$3~/^1|^2/' /etc/passwd| awk -F : '&#123;print $1,$3,$NF&#125;' 可以多种写法，主要看正则怎么写</code></pre><p>3）表示范围</p><ul><li>/ 从哪里开始 /./ 哪里结束 /  常用</li><li>NR<mark>1，NR</mark>5  从第一行开始到第五行结束   类似于 sed  -n  ‘1,5p’</li></ul><p>4) 特殊模式 BEGIN {} 和 END {}</p><table><thead><tr><th>模式</th><th>含义</th><th>应用场景</th></tr></thead><tbody><tr><td>BEGIN</td><td>里面的内容会在 awk<strong> 读取文件之前</strong>执行</td><td>1）进行简单的统计，计算，不涉及读取文件（<strong>常用</strong>）<br />2）用来处理文件之前，添加个表头（了解）<br />3) 用来定义 awk 变量（很少用，因为可以用 - v）</td></tr><tr><td>END</td><td>里面的内容会在 awk<strong> 读取文件之后</strong>执行</td><td>1）awk 进行统计，一般是过程；<font color=red><strong>先进行计算，最后 END 里面输出结果</strong></font>（常用）<br />2）awk 使用数组，用来输出数组结果（常用）</td></tr></tbody></table><ul><li><p>END {} 统计计算</p></li><li><p>统计方法：</p><table><thead><tr><th>统计方法</th><th>简写形式</th><th>应用场景</th></tr></thead><tbody><tr><td>i++</td><td>i=i+1</td><td>计数型，统计次数</td></tr><tr><td>sum=sum+??</td><td>sum+=??</td><td>求和，累加</td></tr><tr><td>注意：i  sum  都是变量，可以随便写</td><td></td><td></td></tr><tr><td>array[]=array[]+1</td><td>array[]++</td><td>数组分类计算</td></tr></tbody></table></li></ul><pre class=" language-language-bash"><code class="language-language-bash">统计/etc/service里面有多少个空行[root@hadoop102 ~]# awk '/^$/&#123;i++&#125;END&#123;print i&#125;' /etc/services 17#求1到100的和[root@hadoop102 ~]# seq 100|awk '&#123;sum=sum+$1&#125;END&#123;print sum&#125;'5050如果要显示过程则：在条件后跟上print xxx[root@hadoop102 ~]# seq 100|awk '&#123;sum=sum+$1，print sum&#125;END&#123;print sum&#125;'</code></pre><p>5）awk 数组</p><ul><li>统计日志：类似于统计个每个 ip 出现的字数，统计每种状态码出现的次数 / 统计系统中每个用户被攻击的次数等等…</li><li>累加求和；统计每个 ip 消耗的流量</li></ul><table><thead><tr><th></th><th>shell 数组</th><th>awk 数组</th><th></th></tr></thead><tbody><tr><td>形式</td><td>array[0]=jiujiu   array[1]=like</td><td>array[0]=jiujiu   array[1]=like</td><td></td></tr><tr><td>使用</td><td>echo $(array[0])   echo $(array[1])</td><td>print array[0]  array[1]</td><td></td></tr><tr><td>批量输出数组内容</td><td>for i in $(array[*])<br />do<br />    echo $i <br />done</td><td>for (i in array)<br />      print i <br />      print  [i]</td><td>awk 数组专用循环，变量获取到的是数组的下标，如果想要数组内容 用 a [i]   注释 1</td></tr></tbody></table><pre class=" language-language-bash"><code class="language-language-bash">#awk数组一般定义和使用[root@hadoop102 ~]# awk 'BEGIN&#123;a[0]=jiujiu;a[1]=like; print a[0],a[1]&#125;' [root@hadoop102 ~]# #这里显示空白是因为在awk中字母会被识别为变量，如果只是想[root@hadoop102 ~]# #使用字符串需要用双引号引起来[root@hadoop102 ~]# #数字不受影响[root@hadoop102 ~]# awk 'BEGIN&#123;a[0]=123;a[1]=321; print a[0],a[1]&#125;'123 321[root@hadoop102 ~]# awk 'BEGIN&#123;a[0]="jiujiu";a[1]="like"; print a[0],a[1]&#125;'jiujiu like</code></pre><pre class=" language-language-bash"><code class="language-language-bash">#注释1：awk数组专用[root@hadoop102 ~]# awk 'BEGIN&#123;a[0]=123;a[1]=321; for (i in a) print i&#125;'01[root@hadoop102 ~]# awk 'BEGIN&#123;a[0]=123;a[1]=321; for (i in a) print a[i]&#125;'123321</code></pre><p>练习题：</p><pre class=" language-language-bash"><code class="language-language-bash">#统计以下域名出现次数(用awk)https://blog.driverzeng.com/index.htmlhttps://blog.driverzeng.com/index.htmlhttps://blog.driverzeng.com/index.htmlhttps://blog.driverzeng.com/1.htmlhttp://post.driverzeng.com/index.htmlhttps://blog.driverzeng.com/1.htmlhttps://blog.driverzeng.com/1.htmlhttp://mp3.driverzeng.com/index.htmlhttps://blog.driverzeng.com/1.htmlhttps://blog.driverzeng.com/3.htmlhttp://post.driverzeng.com/2.htmlhttp://post.driverzeng.com/2.htmlhttp://post.driverzeng.com/2.htmlhttp://post.driverzeng.com/2.htmlhttp://post.driverzeng.com/2.htmlhttp://post.driverzeng.com/2.html[root@hadoop102 ~]# cat 111 | awk -F '/' '&#123;array[$3]++&#125;END&#123;for (i in array)print i,array[i]&#125;' 111 blog.driverzeng.com 8post.driverzeng.com 7mp3.driverzeng.com 1#array[]++ 你要统计什么  []里面就是什么(某一列#比如：统计access.log中ip出现的次数  array[$1]</code></pre><p>注意：使用 awk 统计日志，尽量精确匹配</p><p>6）for 循环 /if 判断</p><table><thead><tr><th>shell 编程 c 语言 for 循环</th><th>awk  for 循环</th><th></th></tr></thead><tbody><tr><td>for((i=1;i&lt;=10;i++))<br />do<br />      echo '$i’<br />down</td><td>for(i=1;1&lt;=10;i++)<br />print i</td><td>awk  for 循环用来循环每个字段</td></tr></tbody></table><pre class=" language-language-bash"><code class="language-language-bash">例：1+100的和[root@hadoop102 ~]# awk 'BEGIN&#123;for(i=1;i<=100;i++)sum+=i;print sum&#125;'5050[root@hadoop102 ~]# awk 'BEGIN&#123;for(i=1;i<=100;i++)sum+=i;print sum&#125;'5050</code></pre><p>if 判断</p><table><thead><tr><th>shell  if    判断</th><th>awk  if  判断</th><th></th></tr></thead><tbody><tr><td>if[“who” -eq  20 ];then<br />     echo ’成年人’<br />fi</td><td>if（条件）<br /> print &quot; 成年人”</td><td>常用</td></tr><tr><td>if[“who” -eq  20 ];then<br />     echo ’成年人’<br /> else<br />     echo &quot; 未成年人 “<br /> fi</td><td>if（条件）<br />      print &quot; 成年人”<br /> else<br />      print &quot; 未成年人 “</td><td></td></tr></tbody></table><p>例子：</p><pre class=" language-language-bash"><code class="language-language-bash">统计磁盘空间使用率，如果大于1%，则提示磁盘空间不足，并显示磁盘分区，磁盘使用率，磁盘挂载点[root@hadoop102 ~]# df -hFilesystem               Size  Used Avail Use% Mounted ondevtmpfs                 2.1G     0  2.1G   0% /devtmpfs                    2.1G     0  2.1G   0% /dev/shmtmpfs                    2.1G   12M  2.1G   1% /runtmpfs                    2.1G     0  2.1G   0% /sys/fs/cgroup/dev/mapper/centos-root   45G  1.5G   44G   4% //dev/sda1                3.0G  138M  2.9G   5% /boottmpfs                    423M     0  423M   0% /run/user/0[root@hadoop102 ~]# df -h | awk -F '[ %]+' 'NR>1&#123;if($5>=1)print "disk no enough",$1,$5,$NF&#125;'disk no enough tmpfs 1 /rundisk no enough /dev/mapper/centos-root 4 /disk no enough /dev/sda1 5 /boot#注意：awk使用多个条件的时候，第一个条件可以放在‘条件&#123;动作&#125;’ 第二个条件一般使用if判断</code></pre><p>试题：</p><p>统计这段语句中，单词字符数小于 6 的单词 ，显示出来</p><p>Life is too short to spend time with people who suck the happiness out of you</p><pre class=" language-language-bash"><code class="language-language-bash">[root@hadoop102 ~]# echo Life is too short to spend time with people who suck the happiness out of youawk '&#123;for(i=1;i<=NF;i++) if(length($i)<6) print $i&#125;'Lifeistooshorttospendtimewithwhosucktheoutofyou</code></pre><p>awk 函数</p><pre class=" language-language-bash"><code class="language-language-bash">length：统计[root@hadoop102 ~]# echo jiujiu | awk '&#123;print length()&#125;'6[root@hadoop102 ~]# echo jiujiu like | awk '&#123;print length($1)&#125;'6[root@hadoop102 ~]# echo jiujiu like | awk '&#123;print length($2)&#125;'4如果不属于$1/$2则默认$0整行输出</code></pre><p>正则支持表</p><table><thead><tr><th>字符</th><th>说明</th><th>Basic RegEx</th><th>Extended RegEx</th><th>python RegEx</th><th>Perl regEx</th></tr></thead><tbody><tr><td>转义</td><td></td><td>\</td><td>\</td><td>\</td><td>\</td></tr><tr><td>^</td><td>匹配行首，例如’^dog’匹配以字符串 dog 开头的行（注意：awk 指令中，’^' 则是匹配字符串的开始）</td><td>^</td><td>^</td><td>^</td><td>^</td></tr><tr><td>$</td><td>匹配行尾，例如：’^、dog 匹配以字符串为结尾的行（注意：指令中，' 则是匹配字符串的结尾）</td><td>$</td><td>$</td><td>$</td><td>$</td></tr><tr><td>^$</td><td>匹配空行</td><td>^$</td><td>^$</td><td>^$</td><td>^$</td></tr><tr><td>^string$</td><td>匹配行，例如：’^dog$' 匹配只含一个字符串 dog 的行</td><td>^string$</td><td>^string$</td><td>^string$</td><td>^string$</td></tr><tr><td>&lt;</td><td>匹配单词，例如：’&lt;frog’ （等价于’\bfrog’），匹配以 frog 开头的单词</td><td>&lt;</td><td>&lt;</td><td><strong>不支持</strong></td><td><strong>不支持</strong>（但可以使用 \b 来匹配单词，例如：’\bfrog’）</td></tr><tr><td>&gt;</td><td>匹配单词，例如：‘frog&gt;’（等价于’frog\b '），匹配以 frog 结尾的单词</td><td>&gt;</td><td>&gt;</td><td><strong>不支持</strong></td><td><strong>不支持</strong>（但可以使用 \b 来匹配单词，例如：‘frog\b’）</td></tr><tr><td><x></td><td>匹配一个单词或者一个特定字符，例如：’<frog>’（等价于’\bfrog\b’）、’<G>’</td><td><x></td><td><x></td><td><strong>不支持</strong></td><td><strong>不支持</strong>（但可以使用 \b 来匹配单词，例如：’\bfrog\b’</td></tr><tr><td>()</td><td>匹配表达式，例如：不支持’（frog）’</td><td><strong>不支持</strong>（但可以使用，如：dogdog</td><td>()</td><td>()</td><td>()</td></tr><tr><td></td><td>匹配表达式，例如：不支持’（frog）’</td><td></td><td><strong>不支持</strong>（同 ())</td><td><strong>不支持</strong>（同 ())</td><td><strong>不支持</strong>（同 ())</td></tr><tr><td>？</td><td>匹配前面的子表达式 0 次或 1 次（等价于 {0,1}），例如：where (is)? 能匹配 &quot;where&quot; 以及 &quot;whereis&quot;</td><td><strong>不支持</strong>（同？)</td><td>？</td><td>？</td><td>？</td></tr><tr><td>?</td><td>匹配前面的子表达式 0 次或 1 次（等价于’{0,1}’），例如：'whereisis? ' 能匹配 “where&quot;以及&quot;whereis”</td><td>?</td><td><strong>不支持</strong>（同？)</td><td><strong>不支持</strong>（同？)</td><td><strong>不支持</strong>（同？)</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符（*, +, ?, {n},{n,}, {n,m}） 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，‘o+?’ 将匹配单个 &quot;o&quot;，而 ‘o+’ 将匹配所有 ‘o’</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td><strong>不支持</strong></td></tr><tr><td>.</td><td>匹配除换行符（’\n’）之外的任意单个字符（注意：awk 指令中的句点能匹配换行符）</td><td>.</td><td>.（如果要匹配包括 “\n” 在内的任何一个字符，请使用：’(^$)|（.）</td><td>.</td><td>.（如果要匹配包括 “\n” 在内的任何一个字符，请使用：’ [.\n] ’</td></tr><tr><td>*</td><td>匹配前面的子表达式 0 次或多次（等价于 {0,}），例如：zo* 能匹配 &quot;z&quot; 以及 “zoo”</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>+</td><td>匹配前面的子表达式 1 次或多次（等价于’{1,}’），例如：'whereisis+ ' 能匹配 “whereis&quot;以及&quot;whereisis”</td><td>+</td><td><strong>不支持</strong>（同 +)</td><td><strong>不支持</strong>（同 +)</td><td><strong>不支持</strong>（同 +)</td></tr><tr><td>+</td><td>匹配前面的子表达式 1 次或多次（等价于 {1,}），例如：zo + 能匹配 &quot;zo&quot; 以及 “zoo”，但不能匹配 “z”</td><td><strong>不支持</strong>（同 +)</td><td>+</td><td>+</td><td>+</td></tr><tr n=""><td n=""></td><td>n 必须是一个 0 或者正整数，匹配子表达式 n 次，例如：zo {2} 能匹配</td><td><strong>不支持</strong>（同 {n})</td><td n=""></td><td n=""></td><td></td></tr><tr n,=""><td n,=""></td><td 2,="">“zooz”，但不能匹配 &quot;Bob&quot;n 必须是一个 0 或者正整数，匹配子表达式大于等于 n 次，例如：go</td><td><strong>不支持</strong>（同 {n,})</td><td n,=""></td><td n,=""></td><td></td></tr><tr n,m=""><td n,m=""></td><td>能匹配 “good”，但不能匹配 godm 和 n 均为非负整数，其中 n &lt;= m，最少匹配 n 次且最多匹配 m 次 ，例如：o {1,3} 将配 &quot;fooooood&quot; 中的前三个 o（请注意在逗号和两个数之间不能有空格）</td><td><strong>不支持</strong>（同 {n,m})</td><td n,m=""></td><td n,m=""></td><td></td></tr><tr><td>x|y</td><td>匹配 x 或 y，例如： 不支持’z|（food）’ 能匹配 “z” 或 &quot;food&quot;；’（z|f）ood’ 则匹配 &quot;zood&quot; 或 “food”</td><td><strong>不支持</strong>（同 x|y)</td><td>x|y</td><td>x|y</td><td>x|y</td></tr><tr><td>[0-9]</td><td>匹配从 0 到 9 中的任意一个数字字符（注意：要写成递增）</td><td>[0-9]</td><td>[0-9]</td><td>[0-9]</td><td>[0-9]</td></tr><tr><td>[xyz]</td><td>字符集合，匹配所包含的任意一个字符，例如：’[abc]' 可以匹配 &quot;lay&quot; 中的 ‘a’（注意：如果元字符，例如：. * 等，它们被放在 [ ] 中，那么它们将变成一个普通字符）</td><td>[xyz]</td><td>[xyz]</td><td>[xyz]</td><td>[xyz]</td></tr><tr><td>[^xyz]</td><td>负值字符集合，匹配未包含的任意一个字符（注意：不包括换行符），例如：’[^abc]’ 可以匹配 “Lay” 中的’L’（注意：[^xyz] 在 awk 指令中则是匹配未包含的任意一个字符 + 换行符）</td><td>[^xyz]</td><td>[^xyz]</td><td>[^xyz]</td><td>[^xyz]</td></tr><tr><td>[A-Za-z]</td><td>匹配大写字母或者小写字母中的任意一个字符（注意：要写成递增）</td><td>[A-Za-z]</td><td>[A-Za-z]</td><td>[A-Za-z]</td><td>[A-Za-z]</td></tr><tr><td>[^A-Za-z]</td><td>匹配除了大写与小写字母之外的任意一个字符（注意：写成递增）</td><td>[^A-Za-z]</td><td>[^A-Za-z]</td><td>[^A-Za-z]</td><td>[^A-Za-z]</td></tr><tr><td><strong>\d</strong></td><td>匹配从 0 到 9 中的任意一个数字字符（等价于 [0-9]）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\d</td><td>\d</td></tr><tr><td><strong>\D</strong></td><td>匹配非数字字符（等价于 [^0-9]）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\D</td><td>\D</td></tr><tr><td>\S</td><td>匹配任何非空白字符（等价于 [^\f\n\r\t\v]）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\S</td><td>\S</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等（等价于 [\f\n\r\t\v]）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\s</td><td>\s</td></tr><tr><td>\W</td><td>匹配任何非单词字符 (等价于 [^A-Za-z0-9_])</td><td>\W</td><td>\W</td><td>\W</td><td>\W</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符（等价于 [A-Za-z0-9_]）</td><td>\w</td><td>\w</td><td>\w</td><td>\w</td></tr><tr><td>\B</td><td>匹配非单词边界，例如：‘er\B’ 能匹配 “verb” 中的’er’，但不能匹配 &quot;never&quot; 中的’er’</td><td>\B</td><td>\B</td><td>\B</td><td>\B</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置，例如： ‘er\b’ 可以匹配 &quot;never&quot; 中的 ‘er’，但不能匹配 “verb” 中的’er’</td><td>\b</td><td>\b</td><td>\b</td><td>\b</td></tr><tr><td>\t</td><td>匹配一个横向制表符（等价于 \x09 和 \cI）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\t</td><td>\t</td></tr><tr><td>\v</td><td>匹配一个垂直制表符（等价于 \x0b 和 \cK）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\v</td><td>\v</td></tr><tr><td>\n</td><td>匹配一个换行符（等价于 \x0a 和 \cJ）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\n</td><td>\n</td></tr><tr><td>\f</td><td>匹配一个换页符（等价于 \x0c 和 \cL）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\f</td><td>\f</td></tr><tr><td>\r</td><td>匹配一个回车符（等价于 \x0d 和 \cM）</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td>\r</td><td>\r</td></tr><tr><td>\</td><td>匹配转义字符本身 &quot;&quot;</td><td>\</td><td>\</td><td>\</td><td>\</td></tr><tr><td>\cx</td><td>匹配由 x 指明的控制字符，例如：\cM 匹配一个 Control-M 或回车符，x 的值必须为 A-Z 或 a-z 之一，否则，将 c 视为一个原义的 ‘c’ 字符</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td></td><td>\cx</td></tr><tr><td>\xn</td><td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长，例如：’\x41’ 匹配 “A”。’\x041’ 则等价于’\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码</td><td><strong>不支持</strong></td><td><strong>不支持</strong></td><td></td><td>\xn</td></tr><tr><td>\num</td><td>匹配 num，其中 num 是一个正整数。表示对所获取的匹配的引用</td><td><strong>不支持</strong></td><td>\num</td><td>\num</td><td></td></tr><tr><td>[:alnum:]</td><td>匹配任何一个字母或数字（[A-Za-z0-9]），例如：’[[:alnum:]] ’</td><td>[:alnum:]</td><td>[:alnum:]</td><td>[:alnum:]</td><td>[:alnum:]</td></tr><tr><td>[:alpha:]</td><td>匹配任何一个字母（[A－Za－z]）， 例如：’ [[:alpha:]] ’</td><td>[:alpha:]</td><td>[:alpha:]</td><td>[:alpha:]</td><td>[:alpha:]</td></tr><tr><td>[:digit:]</td><td>匹配任何一个数字（[0-9]），例如：’[[:digit:]] ’</td><td>[:digit:]</td><td>[:digit:]</td><td>[:digit:]</td><td>[:digit:]</td></tr><tr><td>[:lower:]</td><td>匹配任何一个小写字母（[a-z]）， 例如：’ [[:lower:]] ’</td><td>[:lower:]</td><td>[:lower:]</td><td>[:lower:]</td><td>[:lower:]</td></tr><tr><td>[:upper:]</td><td>匹配任何一个大写字母（[A-Z]）</td><td>[:upper:]</td><td>[:upper:]</td><td>[:upper:]</td><td>[:upper:]</td></tr><tr><td>[:space:]</td><td>任何一个空白字符： 支持制表符、空格，例如：’ [[:space:]] ’</td><td>[:space:]</td><td>[:space:]</td><td>[:space:]</td><td>[:space:]</td></tr><tr><td>[:blank:]</td><td>空格和制表符（横向和纵向），例如：’[[:blank:]]‘ó’[\s\t\v]’</td><td>[:blank:]</td><td>[:blank:]</td><td>[:blank:]</td><td>[:blank:]</td></tr><tr><td>[:graph:]</td><td>任何一个可以看得见的且可以打印的字符（注意：不包括空格和换行符等），例如：’[[:graph:]] ’</td><td>[:graph:]</td><td>[:graph:]</td><td>[:graph:]</td><td>[:graph:]</td></tr><tr><td>[:print:]</td><td>任何一个可以打印的字符（注意：不包括：[:cntrl:]、字符串结束符’\0’、EOF 文件结束符（-1）， 但包括空格符号），例如：’[[:print:]] ’</td><td>[:print:]</td><td>[:print:]</td><td>[:print:]</td><td>[:print:]</td></tr><tr><td>[:cntrl:]</td><td>任何一个控制字符（ASCII 字符集中的前 32 个字符，即：用十进制表示为从 0 到 31，例如：换行符、制表符等等），例如：’ [[:cntrl:]]’</td><td>[:cntrl:]</td><td>[:cntrl:]</td><td>[:cntrl:]</td><td>[:cntrl:]</td></tr><tr><td>[:punct:]</td><td>任何一个标点符号（不包括：[:alnum:]、[:cntrl:]、[:space:] 这些字符集）</td><td>[:punct:]</td><td>[:punct:]</td><td>[:punct:]</td><td>[:punct:]</td></tr><tr><td>[:xdigit:]</td><td>任何一个十六进制数（即：0-9，a-f，A-F）</td><td>[:xdigit:]</td><td>[:xdigit:]</td><td>[:xdigit:]</td><td>[:xdigit:]</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;三剑客 grep 丶 awk 丶 sed&lt;/p&gt;
&lt;p&gt;正则表达式&lt;/p&gt;
&lt;p&gt;1.1 什么是正则表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配一些&lt;font color = &#39;red&#39;&gt;有规律的&lt;/font&gt;东西，比如手机号丶日志文件等&lt;/li&gt;
&lt;li&gt;正则表达式 regul</summary>
      
    
    
    
    
  </entry>
  
</feed>
